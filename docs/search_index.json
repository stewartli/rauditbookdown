[["index.html", "Data Analytics in R For Accounting Professionals About the Author", " Data Analytics in R For Accounting Professionals Stewart Li 2021-11-30 About the Author Stewart Li is a consultant with RAudit Solution LLP. He is a Chartered Accountant and specialized in data analytics and data science in the area of internal control and forensic accounting. Visit the website to see his work. "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction Financial statements is vital component of economic activities. The whole finance department is dedicated to prepare financial statements. Accounting functions can be broken down into Forecast Planning &amp; Analysis (FP&amp;A), General Ledger (GL), Record to Report (R2R), Procurement to Payment (P2P), Order to Cash (O2C), Treasury, Internal Audit, Forensic Accounting, and IT Audit (IA), Tax, Administration, Sectary, Outsource firms in accordance with ERP processes. External Auditors work under massive pressure to ensure that financial statements are presented in the basis of true and fair. Analysts typically evaluate financial statements and its ratios and metrics in the hope of a better investment opportunity. This book refers them as accounting professionals since their work is around financial statements. Financial statements could be affected by corporate strategy, internal control environment, FRSs adoption, relevant regulations, and others. However, this book only concerns financial statements data itself. df &lt;- tibble::tribble( ~from, ~to, &#39;Financial statements&#39;, &#39;Accountant&#39;, &#39;Financial statements&#39;, &#39;External Auditor&#39;, &#39;Financial statements&#39;, &#39;Analyst&#39;, &#39;Accountant&#39;, &#39;FP&amp;A&#39;, &#39;Accountant&#39;, &#39;P2P, O2C\\nTreasury&#39;, &#39;Accountant&#39;, &#39;GL, R2R\\nTax, &#39;, &#39;Accountant&#39;, &#39;IA, IT\\nForensic&#39;, &#39;Accountant&#39;, &#39;Admin\\nOutsource&#39;, &#39;External Auditor&#39;, &#39;Control\\nEnv.&#39;, &#39;External Auditor&#39;, &#39;FRSs&#39;, &#39;Analyst&#39;, &#39;Strategry&#39;, &#39;Analyst&#39;, &#39;Regurlations&#39;, ) igraph::graph_from_data_frame(df) %&gt;% ggraph::ggraph(layout = &#39;dendrogram&#39;) + ggraph::geom_edge_diagonal() + ggraph::geom_node_label(aes(label = name), fill = &quot;#F9D1D1&quot;) + theme_void() Accounting professionals employ a a wide variety of data analytics tools. For instance, FP&amp;A and GL extract data from TM1 and present the results in Excel. External Auditors utilize CAATs ranges from Excel, IDEA, ACL to Tableau, PowerBI, Qlik, and Alteryx over the course of auditing. Analysts build financial models via Excel VBA. As data goes bigger and problems become more complex, those GUI tools become increasingly challenging to work with and their limitations on the performance show up. It has been believed that computer programming languages like R and Python will be a ultimate tool for accounting professionals. Programming codes, text like, allow you to freely express yourself compared to the complicated formula of GUI tools. Business problems can be easily translated into codes in a sensible logical way in which accounting professionals approach them. Whats more, accounting professional can apply R and Python along with those GUI tools as preferred as all tools are integrated well. An obvious advantage to using programming languages is that free open source software, R and Python, have a large and growing global community which provide the ability to do both general and specialized tasks and solve any edge cases accounting professionals might face. Increasing focus on data analytics in recent years means that the ability to enhance the improvement of effectiveness and efficiency will be of great interest in practice. Current trends away from manual process and the rise of Robotic Process Automation (RPA) will likely result in greater requirements for accounting professionals in order to automatize repetitive work processes. More and more organizations recognize potential substantial value to be gained from the application of R and Python in corporate settings, and seek to understand better how to integrate with their exiting workflows. As matter of fact, this book is inspired by a meeting with one of our clients. But, the problem is that few accounting professionals really know how to do data analysis in R and Python. It is still considered by many as a IT thing. Given the pressing circumstances, they should be thinking about how to reflect R and Python in their work. This book presents a practical implementation of R for accounting professionals in this regard. As this book is intended to be more of a technical manual and targeted at technical practitioners, we aims to show how accounting professionals can achieve the improvement in efficiency and effectiveness using R and do not explain accounting concepts and codes in details. We assumes you are a chartered accountant who have a basic knowledge of computer programming languages. If you have never programmed before, you can get a better sense of it after read Chapter 2. We also provide some pointers for you to study further if there are better books to explain relevant concepts and codes. Our focus has been primarily on teaching data analysis of sales records and general ledger using R in a accounting related context. In order to cover as many key techniques as possible, we try not to repeat code and will do the same thing in different ways. As you read through the book, you will quickly grasp knowledge for the application of these techniques in your work and see benefit from it. That said, use cases and examples in the book will clearly point to the motivation of the analysis and usefulness of functions in practice. This book follows a clear flowchart of data analytics and science from R4DS. Common data analytics functions used by accounting professionals appear throughout the book. Such as count, arrange, summarize, pivot_, recode, mutate, filter, slice. From Chapter 2 onwards, this book takes the following structure: - Chapter 2 introduces R in a common structural way in which other computer programming languages has same components with slightly different implementation. - Chapter 3 and 4 analyze sales records from FP&amp;A perspective. It demonstrate how to extract, transform and load (ETL) data from database and query the database via R and SQL interchangeably. It then proceeds to validate data, perform exploratory data analysis (EDA), and create report and dashboard. - Chapter 5 perform audit procedures on general ledger from external auditors points of view. It goes through a variety of technical options for different audit phases. - Chapter 6 looks at the various utility tools which would not fit elsewhere in the book, and yet be important enough to mention. This book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. The code contained in this book is available under the MIT license. If you acknowledge the source and use the contents or any examples of this book for teaching purposes, you dont need to ask the permission to do so. My thank to various fantastic packages authors in R and Python community whose work allows me to write this book. I would like to thank various people who helped us make this book better by reading early drafts. "],["intror.html", "Chapter 2 R basics 2.1 Setup 2.2 Help 2.3 Variable 2.4 Data structure 2.5 Control flow 2.6 Function 2.7 OOP 2.8 IO 2.9 System", " Chapter 2 R basics Most of computer programmings have a similar language structure which includes variable, data types, data structures, logical flow, functions, object orientation programming (OOP), modules, IO operations, and system call. In this structural way, the chapter covers R basics that will provide you some comfort to proceed. However, it is not intended to include all aspects of R. Many more existing resources would be recommended and you are advised to consult these resources in case you dont understand a certain topic. 2.1 Setup To start using R, you need to install R, RStudio, and Git Bash. Lets get familiar with RStudio IDE and a couple of handy shortcuts. 1. RStudio IDE 3 columns layout: Tools &gt; Global Options &gt; Pane Layout &gt; Add Column 2. Move around among panes: Ctrl + 1, Ctrl + 2, Ctrl + 3, etc. 3. Command palette: Ctrl + Shift + P 4. Go to a file: Ctrl + . 5. Assignment operator &lt;-: Alt + - 6. Magrittr pipe %&gt;%: Ctrl + Shift + M 7. Insert code chunk in Rmarkdown document: Ctrl + Alt + I knitr::include_graphics(&quot;img/rstudio_ide.png&quot;) Besides Base R, the book also uses other packages. Running the following codes will install and load those packages. Assuming all the required external packages have been properly installed, we are good to go. pkgs &lt;- c(&quot;tidyverse&quot;, &quot;data.table&quot;, &quot;lubridate&quot;, &quot;httr&quot;, &quot;rvest&quot;, &quot;usethis&quot;, &quot;cli&quot;, &quot;crayon&quot;, &quot;R6&quot;, &quot;validate&quot;, &quot;cowsay&quot;, &quot;pdftools&quot;, &quot;janitor&quot;, &quot;skimr&quot;, &quot;visdat&quot;, &quot;naniar&quot;, &quot;DBI&quot;, &quot;RSQLite&quot;, &quot;dm&quot;, &quot;dbplyr&quot;, &quot;knitr&quot;, &quot;rmarkdown&quot;, &quot;tinytex&quot;, &quot;kableExtra&quot;, &quot;DT&quot;, &quot;formattable&quot;, &quot;unpivotr&quot;, &quot;tidyxl&quot;, &quot;readxl&quot;, &quot;openxlsx&quot;, &quot;igraph&quot;, &quot;ggraph&quot;, &quot;tidygraph&quot;, &quot;ggforce&quot;, &quot;patchwork&quot;, &quot;treemap&quot;, &quot;table1&quot;, &quot;shiny&quot;, &quot;shinyWidgets&quot;, &quot;bslib&quot;, &quot;thematic&quot;, &quot;tidytext&quot;, &quot;wordcloud2&quot;, &quot;collapsibleTree&quot;, &quot;data.tree&quot;, &quot;benford.analysis&quot;, &quot;corrplot&quot;, &quot;widyr&quot;, &quot;vcd&quot;, &quot;psych&quot;) pkg &lt;- pkgs[which(!pkgs %in% installed.packages())] lapply(pkg, install.packages) lapply(pkgs, library) cowsay::say(what = &quot;Let&#39;s start it!&quot;, by = &quot;pig&quot;, what_color = &quot;red&quot;, by_color = &quot;green&quot;) &gt; &gt; ----- &gt; Let&#39;s start it! &gt; ------ &gt; \\ &gt; \\ &gt; _//| .-~~~-. &gt; _/oo } }-@ &gt; (&#39;&#39;)_ } | &gt; `--&#39;| { }--{ } &gt; //_/ /_/ [nosig] &gt; 2.2 Help Names of all exported functions available in a installed package can be displayed. If any of names is strange to you, run ? or help to read documentation. tibble(f = ls(getNamespace(&quot;base&quot;))) %&gt;% dplyr::filter(str_detect(f, &quot;^f&quot;)) &gt; # A tibble: 53 x 1 &gt; f &gt; &lt;chr&gt; &gt; 1 factor &gt; 2 factorial &gt; 3 fifo &gt; 4 file &gt; 5 file.access &gt; 6 file.append &gt; 7 file.choose &gt; 8 file.copy &gt; 9 file.create &gt; 10 file.exists &gt; # ... with 43 more rows ?`[` help(package = &#39;base&#39;) 2.3 Variable Common data types in R are character, double, integer, logical, complex, and raw. To store those data in a session, variables in the environment are created via &lt;-, =, or assign. Variables subsequently can be read, updated, and deleted (CRUD). A specified operations run on variables are eval to spit out a final result. a &lt;- &quot;helloworld&quot; b &lt;- 3.2 c &lt;- 3L d &lt;- TRUE e &lt;- 1+4i f1 &lt;- charToRaw(a) f2 &lt;- intToBits(d) assign(&quot;g&quot;, 100, envir = globalenv()) get(&quot;g&quot;, globalenv()) &gt; [1] 100 ls() &gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;df&quot; &quot;e&quot; &quot;f1&quot; &quot;f2&quot; &quot;g&quot; g &lt;- 102 eval(g + 2) &gt; [1] 104 An associated data type, bytecode, and size of variables can be checked by varying methods. One date type is converted to another via data cast. typeof(a) &gt; [1] &quot;character&quot; class(b) &gt; [1] &quot;numeric&quot; mode(c) &gt; [1] &quot;numeric&quot; storage.mode(c) &gt; [1] &quot;integer&quot; str(d) &gt; logi TRUE compiler::compile(e) &gt; &lt;bytecode: 0x000000001f46e050&gt; tracemem(e) &gt; [1] &quot;&lt;00000000215EFCC8&gt;&quot; object.size(e) &gt; 64 bytes is.raw(f1) &gt; [1] TRUE is.raw(f2) &gt; [1] TRUE is.numeric(b) &gt; [1] TRUE as.character(b) %&gt;% class() &gt; [1] &quot;character&quot; Strings is a special topic in any computer programming language and have many attributes and methods. For instance, you can manipulate and format strings through regular expression. nchar(a) &gt; [1] 10 chartr(&quot;o&quot;, &quot;-&quot;, a) &gt; [1] &quot;hell-w-rld&quot; substr(a, 2, 4) &gt; [1] &quot;ell&quot; sub(&quot;(w.*)&quot;, &quot; &quot;, a, ignore.case = TRUE) &gt; [1] &quot;hello &quot; gsub(&quot;(w.*)&quot;,&quot; &quot;, a) &gt; [1] &quot;hello &quot; substring(a, regexpr(&quot;(w.*)&quot;, a) + 1) &gt; [1] &quot;orld&quot; formatC(c, width = 4, flag = &quot;0&quot;) &gt; [1] &quot;0003&quot; format(Sys.time(), format = &quot;%U %w %H:%M:%S&quot;) &gt; [1] &quot;48 2 15:30:19&quot; 2.4 Data structure Types of data structure in R are vector, data.frame, matrix, array, and list. vector, data.frame, and list are the most frequently used. vector is a building block of others. Simply call vector to initialize an empty vector. character(3) %&gt;% class() numeric(3) %&gt;% length() integer(3) logical(3) vector(&quot;character&quot;, length = 3) Create a numeric vector and assign to a variable v. Run is and %in% to check if v is a vector and 3 is one of component of v. max and summary give you a statistic description of v. intersect and others are used to compare two vectors. v &lt;- c(rep(1:3, 3)) is(v, &#39;vector&#39;) &gt; [1] TRUE is.vector(v) &gt; [1] TRUE is.atomic(v) &gt; [1] TRUE is.element(3, v) &gt; [1] TRUE 3 %in% v &gt; [1] TRUE max(v) &gt; [1] 3 summary(v) &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. &gt; 1 1 2 2 3 3 intersect(v, c(1:15)) &gt; [1] 1 2 3 setdiff(v, c(3:15)) &gt; [1] 1 2 union(v, c(20:30)) &gt; [1] 1 2 3 20 21 22 23 24 25 26 27 28 29 30 setequal(v, c(1:9)) &gt; [1] FALSE A vector can be a named vector. Thus, either index position or element name is used to slice a piece out of data and complete CRUD operations. names(v) &lt;- letters[1:9] v[&#39;a&#39;] &gt; a &gt; 1 v[4] &gt; d &gt; 1 v[8:9] &gt; h i &gt; 2 3 v[-1] &gt; b c d e f g h i &gt; 2 3 1 2 3 1 2 3 v[&#39;j&#39;] &lt;- 10 v[&#39;i&#39;] &lt;- 12 v &gt; a b c d e f g h i j &gt; 1 2 3 1 2 3 1 2 12 10 v[!names(v) %in% c(&#39;i&#39;)] &gt; a b c d e f g h j &gt; 1 2 3 1 2 3 1 2 10 data.frame is a tabular format and contains columns, rows, and cell values. As such, it is very similar in nature to a typical spreadsheet. Its attributes include dimension (dim) , column names (colnames), and others. It also has multiple methods to compute statistics and manipulate (subset, within, and aggregate) data. df &lt;- data.frame(id = letters[1:10], x = 1:10, y = 11:20) attributes(df) &gt; $names &gt; [1] &quot;id&quot; &quot;x&quot; &quot;y&quot; &gt; &gt; $class &gt; [1] &quot;data.frame&quot; &gt; &gt; $row.names &gt; [1] 1 2 3 4 5 6 7 8 9 10 attr(df, which = &quot;class&quot;) &gt; [1] &quot;data.frame&quot; dim(df) &gt; [1] 10 3 colnames(df) &gt; [1] &quot;id&quot; &quot;x&quot; &quot;y&quot; rownames(df) &gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; head(df, 2);tail(df, 2) &gt; id x y &gt; 1 a 1 11 &gt; 2 b 2 12 &gt; id x y &gt; 9 i 9 19 &gt; 10 j 10 20 colMeans(df[2:3]) &gt; x y &gt; 5.5 15.5 rowSums(df[2:3]) &gt; [1] 12 14 16 18 20 22 24 26 28 30 cumsum(df$x) &gt; [1] 1 3 6 10 15 21 28 36 45 55 pmin(df$y, 15) &gt; [1] 11 12 13 14 15 15 15 15 15 15 df[&#39;y&#39;] &gt; y &gt; 1 11 &gt; 2 12 &gt; 3 13 &gt; 4 14 &gt; 5 15 &gt; 6 16 &gt; 7 17 &gt; 8 18 &gt; 9 19 &gt; 10 20 df[df$y &gt; 18, ] &gt; id x y &gt; 9 i 9 19 &gt; 10 j 10 20 subset(df, y &gt; 18, select = c(1:3)) &gt; id x y &gt; 9 i 9 19 &gt; 10 j 10 20 with(df, quantile(x, c(0.5, 0.75))) &gt; 50% 75% &gt; 5.50 7.75 within(df, {z = x + y}) &gt; id x y z &gt; 1 a 1 11 12 &gt; 2 b 2 12 14 &gt; 3 c 3 13 16 &gt; 4 d 4 14 18 &gt; 5 e 5 15 20 &gt; 6 f 6 16 22 &gt; 7 g 7 17 24 &gt; 8 h 8 18 26 &gt; 9 i 9 19 28 &gt; 10 j 10 20 30 aggregate(df[2:3], list(df$id &gt; &quot;f&quot;), paste0) &gt; Group.1 x y &gt; 1 FALSE 1, 2, 3, 4, 5, 6 11, 12, 13, 14, 15, 16 &gt; 2 TRUE 7, 8, 9, 10 17, 18, 19, 20 Matrix and Array can be create by their constructors respectively. m &lt;- matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE, dimnames = list(c(&quot;X&quot;,&quot;Y&quot;), c(&quot;A&quot;,&quot;B&quot;, &quot;C&quot;))) df_m &lt;- as.data.frame(m) dimnames(df_m) &gt; [[1]] &gt; [1] &quot;X&quot; &quot;Y&quot; &gt; &gt; [[2]] &gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; df_m &gt; A B C &gt; X 1 2 3 &gt; Y 4 5 6 t(df_m) &gt; X Y &gt; A 1 4 &gt; B 2 5 &gt; C 3 6 array(1:24, dim = c(2, 4, 3)) &gt; , , 1 &gt; &gt; [,1] [,2] [,3] [,4] &gt; [1,] 1 3 5 7 &gt; [2,] 2 4 6 8 &gt; &gt; , , 2 &gt; &gt; [,1] [,2] [,3] [,4] &gt; [1,] 9 11 13 15 &gt; [2,] 10 12 14 16 &gt; &gt; , , 3 &gt; &gt; [,1] [,2] [,3] [,4] &gt; [1,] 17 19 21 23 &gt; [2,] 18 20 22 24 List is able to contain any type of data and data structures. Run vector to create an empty list. Slice and CRUD operations on a list are similar as those mentioned above. vector(&quot;list&quot;, length = 3) l &lt;- list(df_m, df) l[[2]] &gt; id x y &gt; 1 a 1 11 &gt; 2 b 2 12 &gt; 3 c 3 13 &gt; 4 d 4 14 &gt; 5 e 5 15 &gt; 6 f 6 16 &gt; 7 g 7 17 &gt; 8 h 8 18 &gt; 9 i 9 19 &gt; 10 j 10 20 l[[&quot;df_m&quot;]] &lt;- c(13:19) append(l, c(20)) &gt; [[1]] &gt; A B C &gt; X 1 2 3 &gt; Y 4 5 6 &gt; &gt; [[2]] &gt; id x y &gt; 1 a 1 11 &gt; 2 b 2 12 &gt; 3 c 3 13 &gt; 4 d 4 14 &gt; 5 e 5 15 &gt; 6 f 6 16 &gt; 7 g 7 17 &gt; 8 h 8 18 &gt; 9 i 9 19 &gt; 10 j 10 20 &gt; &gt; $df_m &gt; [1] 13 14 15 16 17 18 19 &gt; &gt; [[4]] &gt; [1] 20 l[4] &lt;- NULL l &gt; [[1]] &gt; A B C &gt; X 1 2 3 &gt; Y 4 5 6 &gt; &gt; [[2]] &gt; id x y &gt; 1 a 1 11 &gt; 2 b 2 12 &gt; 3 c 3 13 &gt; 4 d 4 14 &gt; 5 e 5 15 &gt; 6 f 6 16 &gt; 7 g 7 17 &gt; 8 h 8 18 &gt; 9 i 9 19 &gt; 10 j 10 20 &gt; &gt; $df_m &gt; [1] 13 14 15 16 17 18 19 2.5 Control flow if and switch (see 2.6) allow you to specify the predefined logical conditions. The expected outcome should be attained after run your script. for and while loop repeat a certain action until the end. if (.Platform$OS.type == &#39;windows&#39;){ sprintf(&quot;You are running on %s&quot;, str_to_title(Sys.info()[&#39;sysname&#39;])) } &gt; [1] &quot;You are running on Windows&quot; while (TRUE) { x &lt;- readline(prompt = &quot;&quot;) if (x == &#39;q&#39;){ break }else{ print(sprintf(&quot;You input is %s&quot;, x)) } } knitr::include_graphics(&quot;img/while_loop.png&quot;) for (i in seq(length(v))){ if (names(v[i]) == &#39;c&#39;){ next } print(v[i]) } &gt; a &gt; 1 &gt; b &gt; 2 &gt; d &gt; 1 &gt; e &gt; 2 &gt; f &gt; 3 &gt; g &gt; 1 &gt; h &gt; 2 &gt; i &gt; 12 &gt; j &gt; 10 In the world of R, a couple of alternatives to for loop are often used due to simplicity and performance. In particular, apply family from base R and map family from purrr. for (i in v){ cat(v[i] * v[i], sep = &quot;\\n&quot;) } &gt; 1 &gt; 4 &gt; 9 &gt; 1 &gt; 4 &gt; 9 &gt; 1 &gt; 4 &gt; NA &gt; 100 sapply(v, function(x) x*x) &gt; a b c d e f g h i j &gt; 1 4 9 1 4 9 1 4 144 100 map_dbl(v, ~.x*.x) &gt; a b c d e f g h i j &gt; 1 4 9 1 4 9 1 4 144 100 2.6 Function Functions usually take one or more arguments as inputs and return an one or more desired outputs. For instance, a high order function takes an anonymous function as an argument. A function is viewed as a series of operations represented by an abstract syntax tree (ast). Refer to Advanced R for details. Map(function(x) x*x, v) &gt; $a &gt; [1] 1 &gt; &gt; $b &gt; [1] 4 &gt; &gt; $c &gt; [1] 9 &gt; &gt; $d &gt; [1] 1 &gt; &gt; $e &gt; [1] 4 &gt; &gt; $f &gt; [1] 9 &gt; &gt; $g &gt; [1] 1 &gt; &gt; $h &gt; [1] 4 &gt; &gt; $i &gt; [1] 144 &gt; &gt; $j &gt; [1] 100 Filter(function(x) x &gt; 3, v) &gt; i j &gt; 12 10 Reduce(paste, v, accumulate = TRUE) &gt; [1] &quot;1&quot; &quot;1 2&quot; &quot;1 2 3&quot; &gt; [4] &quot;1 2 3 1&quot; &quot;1 2 3 1 2&quot; &quot;1 2 3 1 2 3&quot; &gt; [7] &quot;1 2 3 1 2 3 1&quot; &quot;1 2 3 1 2 3 1 2&quot; &quot;1 2 3 1 2 3 1 2 12&quot; &gt; [10] &quot;1 2 3 1 2 3 1 2 12 10&quot; args(Map) &gt; function (f, ...) &gt; NULL formals(Map) &gt; $f &gt; &gt; &gt; $... lobstr::ast(Map(function(x) x*x, v)) &gt; o-Map &gt; +-o-`function` &gt; | +-o-x = `` &gt; | +-o-`*` &gt; | | +-x &gt; | | \\-x &gt; | \\-&lt;inline srcref&gt; &gt; \\-v Computer programming languages are very powerful because they allow users to write their own functions to meet their special needs. The following two examples illustrate how to write a function with switch and {{}} from rlang and use stopifnot for error handling. st_do &lt;- function(df, f, variable, ...){ switch (f, select = df %&gt;% select({{variable}}), filter = df %&gt;% dplyr::filter(mpg &gt; 20), mutate = df %&gt;% mutate(...) ) } st_do(mtcars, &#39;select&#39;, variable = c(contains(&#39;p&#39;), starts_with(&#39;a&#39;))) &gt; mpg disp hp am &gt; Mazda RX4 21.0 160.0 110 1 &gt; Mazda RX4 Wag 21.0 160.0 110 1 &gt; Datsun 710 22.8 108.0 93 1 &gt; Hornet 4 Drive 21.4 258.0 110 0 &gt; Hornet Sportabout 18.7 360.0 175 0 &gt; Valiant 18.1 225.0 105 0 &gt; Duster 360 14.3 360.0 245 0 &gt; Merc 240D 24.4 146.7 62 0 &gt; Merc 230 22.8 140.8 95 0 &gt; Merc 280 19.2 167.6 123 0 &gt; Merc 280C 17.8 167.6 123 0 &gt; Merc 450SE 16.4 275.8 180 0 &gt; Merc 450SL 17.3 275.8 180 0 &gt; Merc 450SLC 15.2 275.8 180 0 &gt; Cadillac Fleetwood 10.4 472.0 205 0 &gt; Lincoln Continental 10.4 460.0 215 0 &gt; Chrysler Imperial 14.7 440.0 230 0 &gt; Fiat 128 32.4 78.7 66 1 &gt; Honda Civic 30.4 75.7 52 1 &gt; Toyota Corolla 33.9 71.1 65 1 &gt; Toyota Corona 21.5 120.1 97 0 &gt; Dodge Challenger 15.5 318.0 150 0 &gt; AMC Javelin 15.2 304.0 150 0 &gt; Camaro Z28 13.3 350.0 245 0 &gt; Pontiac Firebird 19.2 400.0 175 0 &gt; Fiat X1-9 27.3 79.0 66 1 &gt; Porsche 914-2 26.0 120.3 91 1 &gt; Lotus Europa 30.4 95.1 113 1 &gt; Ford Pantera L 15.8 351.0 264 1 &gt; Ferrari Dino 19.7 145.0 175 1 &gt; Maserati Bora 15.0 301.0 335 1 &gt; Volvo 142E 21.4 121.0 109 1 st_do(mtcars, &#39;filter&#39;) &gt; mpg cyl disp hp drat wt qsec vs am gear carb &gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 &gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 &gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 &gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 &gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 &gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 &gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 &gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 &gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 &gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 &gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 &gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 &gt; Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 &gt; Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 st_do(mtcars, &#39;mutate&#39;, mpg2 = mpg/10) &gt; mpg cyl disp hp drat wt qsec vs am gear carb mpg2 &gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 2.10 &gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 2.10 &gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 2.28 &gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 2.14 &gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 1.87 &gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 1.81 &gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 1.43 &gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 2.44 &gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 2.28 &gt; Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 1.92 &gt; Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 1.78 &gt; Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 1.64 &gt; Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 1.73 &gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 1.52 &gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 1.04 &gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 1.04 &gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 1.47 &gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 3.24 &gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 3.04 &gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 3.39 &gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 2.15 &gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 1.55 &gt; AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 1.52 &gt; Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 1.33 &gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 1.92 &gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 2.73 &gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 2.60 &gt; Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 3.04 &gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 1.58 &gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 1.97 &gt; Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 1.50 &gt; Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 2.14 st_look &lt;- function(df, var, cond = NULL){ stopifnot(&quot;Your variable is not inside the dataset&quot; = as.integer(any(colnames(df) == substitute(var))) == 1) dim_txt &lt;- dim(df) cli::cli_alert_success(cli::pluralize(&quot;This dataset has {dim_txt[1]} row{?s} and {dim_txt[2]} column{?s}&quot;)) if(!is.null(cond)){ filt_txt &lt;- df %&gt;% dplyr::filter(eval(parse(text = cond))) %&gt;% summarise(across(c({{var}}), tibble::lst(mean, median))) %&gt;% mutate(across(everything(), round, 2)) %&gt;% mutate(across(everything(), crayon::bold)) cli::cli_alert_success(&quot;The mean and median is {filt_txt[1]} and {filt_txt[2]} based on your condition&quot;) }else{ stat_txt &lt;- df %&gt;% summarise(across(c({{var}}), tibble::lst(mean, median))) %&gt;% mutate(across(everything(), round, 2)) %&gt;% mutate(across(everything(), crayon::bold)) cli::cli_alert_success(&quot;The mean and median is {stat_txt[1]} and {stat_txt[2]}&quot;) } usethis::ui_done(crayon::cyan(&quot;You are done here&quot;)) } st_look(mtcars, mpg) st_look(mtcars, mpg, &quot;am == 1&quot;) knitr::include_graphics(&quot;img/st_look.png&quot;) 2.7 OOP Object-oriented programming (OOP) in R has S3, S4, RC, R6. R6 is demonstrated here as it feels like OOP of other computer programming languages. library(R6) library(magrittr) Audit &lt;- R6::R6Class( classname = &quot;Audit&quot;, public = list( df = NA, initialize = function(client, aic, df) { private$client &lt;- client private$aic &lt;- aic self$df &lt;- df self$job() reg.finalizer(self, function(e) print(getwd()), onexit = FALSE) }, set_client = function(client) {private$client &lt;- client}, set_aic = function(aic) {private$aic &lt;- aic}, job = function() { cat(&quot;\\U0001F357&quot;, paste0(private$aic, &quot; is charge of the audit of &quot;, private$client, &quot;&#39;s dataset [&quot;, dim(self$df)[1], &quot; &quot;, dim(self$df)[2], &quot;]&quot;, &quot;.\\n&quot;)) }, describe = function(){ self$df %&gt;% head() %T&gt;% glimpse() } ), private = list( client = NA, aic = NA ) ) xyz &lt;- Audit$new(&quot;XYZ LLP&quot;, &quot;Stewart Li&quot;, mtcars) xyz$df &lt;- iris xyz$describe() xyz$set_aic(&quot;Liu Meng&quot;) xyz$job() gc() knitr::include_graphics(&quot;img/r6.png&quot;) 2.8 IO IO refers to input and output. Computer programming is like a machine which receives and process inputs and produce outputs in many forms. read.table read data copied from a website into R. cat write text inputs out a csv file. read.table(&quot;clipboard&quot;, sep = &quot;\\t&quot;, header = TRUE) knitr::include_graphics(&quot;img/clipboard.png&quot;) txt &lt;- &quot; job, description 1, clean up the dataset 2, data visualization &quot; cat(txt, file = &quot;supplements/memo.csv&quot;) file.show(file.choose()) file.show(&quot;supplements/memo.csv&quot;) file.remove(&quot;supplements/memo.csv&quot;) knitr::include_graphics(&quot;img/cat_csv.png&quot;) 2.9 System system and system2 allow you to run other programmings without leaving the current R environment. For instance, you can call windows calculator program, Bash, Python, and many others. system(&#39;calc&#39;) knitr::include_graphics(&quot;img/calc.png&quot;) Sys.which(&#39;grep&#39;) system2(&quot;cat&quot;, args = c(&quot;supplements/memo.csv&quot;), stdout = TRUE) knitr::include_graphics(&quot;img/bash.png&quot;) readLines(file(here::here(&quot;supplements/syscall.py&quot;))) &gt; [1] &quot;name = &#39;Stewart Li&#39;&quot; &quot;print(f\\&quot;Hi {name}\\&quot;)&quot; system(paste(&#39;python C:/Users/&quot;Stewart Li&quot;/Dropbox/_rauditsolutionllp/github/rauditbook/intror/syscall.py&#39;)) knitr::include_graphics(&quot;img/python.png&quot;) "],["import.html", "Chapter 3 Import 3.1 Dataset 3.2 SQLite", " Chapter 3 Import As data could be stored in a csv file, database, cloud, and others, R facilitates numerous ways of importing data. For data easily fitted in the memory, you usually read it directly into a dataframe through data.table. For slightly bigger data, RSQLite, duckdb and arrow can be very useful in term of performance. Pretend the data live in PostgreSQL database in this case. 3.1 Dataset 3.1.1 Data to database This chapter uses sales data in Excel with multiple worksheets. To put them into a database named stlidb, we need to read Excel worksheets into R and then copy those objects to the database separately. The database now contains eight tables as shown Figure 1. sheet_name &lt;- readxl::excel_sheets(here::here(&quot;data&quot;, &quot;ContosoData.xlsx&quot;))[2:8] df_list &lt;- map(set_names(sheet_name), read_excel, path = here::here(&quot;data&quot;, &quot;ContosoData.xlsx&quot;)) list2env(df_list, envir = .GlobalEnv) Sales &lt;- read_csv(here::here(&#39;data/SampleContosoSalesTable.csv&#39;)) con &lt;- DBI::dbConnect(odbc::odbc(), Driver = &quot;PostgreSQL Unicode&quot;, Database = &quot;stlidb&quot;, UserName = &quot;postgres&quot;, Password = &quot;**********&quot;, Servername = &quot;localhost&quot;, Port = 5432) DBI::dbListTables(con) DBI::dbDisconnect(con) DBI::dbWriteTable(con, &quot;Channel&quot;, value = Channel) DBI::dbWriteTable(con, &quot;Geography&quot;, value = Geography) DBI::dbWriteTable(con, &quot;Product&quot;, value = Product) DBI::dbWriteTable(con, &quot;ProductCategory&quot;, value = ProductCategory) DBI::dbWriteTable(con, &quot;ProductSubCategory&quot;, value = ProductSubCategory) DBI::dbWriteTable(con, &quot;Promotion&quot;, value = Promotion) DBI::dbWriteTable(con, &quot;Stores&quot;, value = Stores) DBI::dbWriteTable(con, &quot;Sales&quot;, value = Sales) knitr::include_graphics(&quot;img/pgAdmin_01.png&quot;) knitr::include_graphics(&quot;img/sqlite_01.png&quot;) 3.1.2 Data model All eight tables are interlinked each other. After added primary and foreign keys to them, their relationship is clearly displayed in Figure 2. stlidb_dm &lt;- dm_from_src(con) stlidb_dm_keys &lt;- stlidb_dm %&gt;% dm_add_pk(Channel, ChannelKey) %&gt;% dm_add_pk(Geography, GeographyKey) %&gt;% dm_add_pk(Product, ProductKey) %&gt;% dm_add_pk(ProductCategory, ProductCategoryKey) %&gt;% dm_add_pk(ProductSubCategory, ProductSubcategoryKey) %&gt;% dm_add_pk(Promotion, PromotionKey) %&gt;% dm_add_pk(Stores, StoreKey) %&gt;% dm_add_pk(Sales, SalesKey) %&gt;% dm_add_fk(Sales, ChannelKey, Channel) %&gt;% dm_add_fk(Sales, StoreKey, Stores) %&gt;% dm_add_fk(Sales, PromotionKey, Promotion) %&gt;% dm_add_fk(Sales, ProductKey, Product) %&gt;% dm_add_fk(Product, ProductSubcategoryKey, ProductSubCategory) %&gt;% dm_add_fk(ProductSubCategory, ProductCategoryKey, ProductCategory) %&gt;% dm_add_fk(Stores, GeographyKey, Geography) stlidb_dm_keys %&gt;% dm_set_colors(lightgreen = c(Channel, Promotion, Stores, Geography), lightpink = c(Product, ProductCategory, ProductSubCategory), grey = Sales) %&gt;% dm_draw(view_type = &#39;all&#39;) knitr::include_graphics(&quot;img/dm.png&quot;) 3.1.3 Join tables Sales table needs to be joined to other tables by primary and foreign keys to eventually obtain the required view of the data. Then, write the combined dataset out as a csv file. If you take a closer look at data, many of its columns are not meaningful or redundant. After removed those unused columns, the sales_df.csv is a final clean dataset on which we will use perform analysis. sales &lt;- stlidb_dm_keys %&gt;% dm_squash_to_tbl(Sales) %&gt;% collect() data.table::fwrite(sales, here::here(&#39;data/sales.csv&#39;)) paste0(&#39;The dataset is &#39;, round(file.size(here::here(&#39;data/sales.csv&#39;))/1000000, 2), &quot; MB&quot;) &gt; [1] &quot;The dataset is 63.81 MB&quot; sales &lt;- read_csv(here::here(&#39;data/sales.csv&#39;)) map_dbl(sales, ~length(unique(.x))) &gt; SalesKey DateKey ChannelKey &gt; 155732 1 4 &gt; StoreKey ProductKey PromotionKey &gt; 306 1689 28 &gt; Sales.UnitCost Sales.UnitPrice SalesQuantity &gt; 397 350 68 &gt; ReturnQuantity ReturnAmount DiscountQuantity &gt; 4 597 20 &gt; DiscountAmount TotalCost SalesAmount &gt; 5113 8453 19146 &gt; ChannelName ProductName ProductDescription &gt; 4 1689 516 &gt; Manufacturer BrandName ClassName &gt; 10 10 3 &gt; Product.UnitCost Product.UnitPrice ProductSubcategoryKey &gt; 397 350 22 &gt; ProductSubcategory ProductCategoryKey ProductCategory &gt; 22 6 6 &gt; PromotionLabel PromotionName DiscountPercent &gt; 28 10 6 &gt; StartDate EndDate GeographyKey &gt; 22 19 263 &gt; StoreType StoreName Status &gt; 4 306 2 &gt; CloseReason EmployeeCount SellingAreaSize &gt; 3 47 15 &gt; GeographyType ContinentName RegionCountryName &gt; 1 3 34 remove_col &lt;- c(&#39;SalesKey&#39;, &#39;DateKey&#39;, &#39;ChannelKey&#39;, &#39;StoreKey&#39;, &#39;ProductKey&#39;, &#39;PromotionKey&#39;, &#39;ProductCategoryKey&#39;, &quot;ProductSubcategoryKey&quot;, &#39;GeographyKey&#39;, &#39;ProductDescription&#39;, &quot;PromotionLabel&quot;, &#39;CloseReason&#39;, &#39;GeographyType&#39;, &#39;Product.UnitCost&#39;, &#39;Product.UnitPrice&#39;) select_col &lt;- c(&#39;Sales.UnitPrice&#39;, &#39;SalesQuantity&#39;, &#39;SalesAmount&#39;, &#39;Sales.UnitCost&#39;, &#39;TotalCost&#39;, &#39;ReturnQuantity&#39;, &#39;ReturnAmount&#39;, &#39;DiscountQuantity&#39;, &#39;DiscountAmount&#39;, &quot;DiscountPercent&quot;, &quot;PromotionName&quot;, &#39;StartDate&#39;, &#39;EndDate&#39;, &#39;ChannelName&#39;, &#39;StoreType&#39;, &#39;StoreName&#39;, &#39;Status&#39;, &#39;EmployeeCount&#39;, &#39;SellingAreaSize&#39;, &#39;ContinentName&#39;, &#39;RegionCountryName&#39;, &#39;ProductName&#39;, &#39;ProductSubcategory&#39;, &#39;ProductCategory&#39;, &#39;Manufacturer&#39;, &#39;BrandName&#39;, &#39;ClassName&#39;) removed &lt;- (names(sales) %&gt;% setdiff(select_col)) all(removed %in% remove_col) &gt; [1] TRUE sales_df &lt;- sales %&gt;% select(all_of(select_col)) data.table::fwrite(sales_df, here::here(&#39;data/sales_df.csv&#39;)) paste0(&#39;The dataset is &#39;, round(file.size(here::here(&#39;data/sales_df.csv&#39;))/1000000, 2), &quot; MB&quot;) &gt; [1] &quot;The dataset is 44.69 MB&quot; 3.2 SQLite R can connect to various databases. It becomes more common to load data into a database and write queries in SQL and R interchangeably in a R session. This section shows a brief example. 3.2.1 Connection con &lt;- DBI::dbConnect(RSQLite::SQLite(), dbname = here::here(&quot;supplements/sales_df.db&quot;)) DBI::dbWriteTable(con, &quot;sales_df&quot;, sales_df, overwrite = TRUE) dplyr::copy_to(con, mtcars, &quot;mtcars&quot;) DBI::dbListTables(con) &gt; [1] &quot;sales_df&quot; DBI::dbListFields(con, &#39;sales_df&#39;) &gt; [1] &quot;sales_unit_price&quot; &quot;sales_quantity&quot; &quot;sales_amount&quot; &gt; [4] &quot;sales_unit_cost&quot; &quot;total_cost&quot; &quot;return_quantity&quot; &gt; [7] &quot;return_amount&quot; &quot;discount_quantity&quot; &quot;discount_amount&quot; &gt; [10] &quot;discount_percent&quot; &quot;promotion_name&quot; &quot;start_date&quot; &gt; [13] &quot;end_date&quot; &quot;channel_name&quot; &quot;store_type&quot; &gt; [16] &quot;store_name&quot; &quot;status&quot; &quot;employee_count&quot; &gt; [19] &quot;selling_area_size&quot; &quot;continent_name&quot; &quot;region_country_name&quot; &gt; [22] &quot;product_name&quot; &quot;product_subcategory&quot; &quot;product_category&quot; &gt; [25] &quot;manufacturer&quot; &quot;brand_name&quot; &quot;class_name&quot; 3.2.2 R code chunk DBI::dbGetQuery(con, &#39;SELECT sales_unit_price, product_category, store_type FROM sales_df LIMIT 3&#39;) &gt; sales_unit_price product_category store_type &gt; 1 299.00 Cell phones Store &gt; 2 38.99 Cell phones Store &gt; 3 16.99 Cell phones Store tbl(con, &quot;sales_df&quot;) %&gt;% select(sales_unit_price, product_category, store_type) %&gt;% dplyr::filter(sales_unit_price &gt; 2800) &gt; # Source: lazy query [?? x 3] &gt; # Database: sqlite 3.34.0 [C:\\Users\\Stewart &gt; # Li\\Dropbox\\_rauditsolutionllp\\github\\rauditbook\\crcbook\\rauditbookdown\\supplements\\sales_df.db] &gt; sales_unit_price product_category store_type &gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &gt; 1 2900. TV and Video Store &gt; 2 2900. TV and Video Reseller &gt; 3 2900. TV and Video Store &gt; 4 2900. TV and Video Store &gt; 5 2900. TV and Video Online &gt; 6 2900. TV and Video Store &gt; 7 2900. TV and Video Reseller &gt; 8 2900. TV and Video Online &gt; 9 2900. TV and Video Reseller &gt; 10 2900. TV and Video Online &gt; # ... with more rows tbl(con, &quot;sales_df&quot;) %&gt;% select(sales_unit_price, product_category, store_type) %&gt;% dplyr::filter(sales_unit_price &gt; 2800) %&gt;% show_query() %&gt;% capture.output() %&gt;% .[2:length(.)] %&gt;% str_replace_all(&quot;`&quot;, &quot;&quot;) %&gt;% str_c(collapse = &quot; &quot;) &gt; [1] &quot;SELECT * FROM (SELECT sales_unit_price, product_category, store_type FROM sales_df) WHERE (sales_unit_price &gt; 2800.0)&quot; 3.2.3 SQL code chunk -- This is a SQL comment SELECT sales_unit_price, product_category, store_type FROM sales_df WHERE sales_unit_price &gt; 2800 LIMIT 3 Table 3.1: 3 records sales_unit_price product_category store_type 2899.99 TV and Video Store 2899.99 TV and Video Reseller 2899.99 TV and Video Store SELECT sales_unit_price, product_category, store_type, AVG(sales_unit_price) OVER (PARTITION BY product_category) AS avg_price, MAX(sales_unit_price) OVER (PARTITION BY product_category) AS max_price FROM sales_df WHERE store_type IN (&#39;Store&#39;, &#39;Online&#39;) ORDER BY product_category, store_type LIMIT 3; max_price &gt; sales_unit_price product_category store_type avg_price max_price &gt; 1 21.57 Audio Online 115.901 299.23 &gt; 2 37.95 Audio Online 115.901 299.23 &gt; 3 67.40 Audio Online 115.901 299.23 You can run an external SQL file inside of code chunk. The result will show up when you knit the document. However, you can preview SQL query result. cat(readr::read_file(&quot;supplements/test.sql&quot;)) &gt; -- !preview conn=con &gt; &gt; SELECT * FROM sales_df LIMIT 6 &lt;!-- ```{sql connection=con, output.var=&quot;sales_df_preview&quot;, code=readLines(&quot;supplements/test.sql&quot;)} --&gt; &lt;!-- ``` --&gt; &lt;!-- ```{r eval=FALSE} --&gt; &lt;!-- sales_df_preview --&gt; &lt;!-- ``` --&gt; DBI::dbDisconnect(con) knitr::include_graphics(&quot;img/sqlite_02.png&quot;) "],["fpa.html", "Chapter 4 FP&amp;A 4.1 Validation 4.2 EDA 4.3 Business ananlysis 4.4 Info graphic 4.5 Report 4.6 Dashboard", " Chapter 4 FP&amp;A In general, FP&amp;A produce a business insight report after analyzed varying source of data. Their workflow includes 1) data extraction out of a database; 2) data validation; 3) thoroughly analysis; 4) graphic presentation; 5) reports in various forms; 6) dashboard. Although this chapter is written from FP&amp;A point of view, techniques can be used by other accounting professionals. 4.1 Validation Data is validated based on your expectation before detailed analysis. For instance, sales unit price is expected to be positive number. sales unit price multiply with sales quantity is expected to equal to sales amount. sales_df &lt;- read_csv(here::here(&#39;data/sales_df.csv&#39;), name_repair = janitor::make_clean_names) library(validate) out &lt;- sales_df %&gt;% validate::check_that( sales_unit_price &gt; 0, sales_unit_cost &gt; 0, sales_quantity &gt; 0, return_quantity &gt;= 0, discount_quantity &gt;= 0, discount_percent &lt; 1, sales_unit_price &gt;= sales_unit_cost, sales_quantity &gt;= return_quantity, sales_quantity &gt;= discount_quantity, abs((sales_unit_price * sales_quantity) - sales_amount) &lt; 10, abs((sales_unit_cost * sales_quantity) - total_cost) &lt; 10, sales_unit_price * return_quantity - return_amount &lt; 10, sales_unit_price * discount_percent * discount_quantity - discount_amount &lt; 10, sales_amount &gt;= total_cost, sales_amount &gt;= return_amount, sales_amount &gt;= discount_amount, end_date - start_date &lt; 365) summary(out) &gt; name items passes fails nNA error warning &gt; 1 V01 155732 155732 0 0 FALSE FALSE &gt; 2 V02 155732 155732 0 0 FALSE FALSE &gt; 3 V03 155732 155732 0 0 FALSE FALSE &gt; 4 V04 155732 155732 0 0 FALSE FALSE &gt; 5 V05 155732 155732 0 0 FALSE FALSE &gt; 6 V06 155732 155732 0 0 FALSE FALSE &gt; 7 V07 155732 155732 0 0 FALSE FALSE &gt; 8 V08 155732 155732 0 0 FALSE FALSE &gt; 9 V09 155732 155732 0 0 FALSE FALSE &gt; 10 V10 155732 107634 48098 0 FALSE FALSE &gt; 11 V11 155732 114188 41544 0 FALSE FALSE &gt; 12 V12 155732 155732 0 0 FALSE FALSE &gt; 13 V13 155732 155732 0 0 FALSE FALSE &gt; 14 V14 155732 155732 0 0 FALSE FALSE &gt; 15 V15 155732 155732 0 0 FALSE FALSE &gt; 16 V16 155732 155732 0 0 FALSE FALSE &gt; 17 V17 155732 89831 65901 0 FALSE FALSE &gt; expression &gt; 1 sales_unit_price &gt; 0 &gt; 2 sales_unit_cost &gt; 0 &gt; 3 sales_quantity &gt; 0 &gt; 4 (return_quantity - 0) &gt;= -1e-08 &gt; 5 (discount_quantity - 0) &gt;= -1e-08 &gt; 6 discount_percent &lt; 1 &gt; 7 (sales_unit_price - sales_unit_cost) &gt;= -1e-08 &gt; 8 (sales_quantity - return_quantity) &gt;= -1e-08 &gt; 9 (sales_quantity - discount_quantity) &gt;= -1e-08 &gt; 10 abs((sales_unit_price * sales_quantity) - sales_amount) &lt; 10 &gt; 11 abs((sales_unit_cost * sales_quantity) - total_cost) &lt; 10 &gt; 12 sales_unit_price * return_quantity - return_amount &lt; 10 &gt; 13 sales_unit_price * discount_percent * discount_quantity - discount_amount &lt; 10 &gt; 14 (sales_amount - total_cost) &gt;= -1e-08 &gt; 15 (sales_amount - return_amount) &gt;= -1e-08 &gt; 16 (sales_amount - discount_amount) &gt;= -1e-08 &gt; 17 end_date - start_date &lt; 365 plot(out) v_amt &lt;- validate::violating(sales_df, out[10:11]) v_date &lt;- validate::violating(sales_df, out[17]) Surprisingly, sales unit price multiply with sales quantity does not equal to sales amount. Those outlier are filter out to be examined in detail. If you were an external auditor and should pay a special attention to those as the sum of those immaterial misstatements becomes significantly material. Furthermore, it is unusual that promotion period (end date minus start date) is more than one year. It could be an error that stores whose status is off incur staff and rental cost. Since the illustration based on dummy data, those discreteness will be ignored subsequently. sales_df[sample(nrow(sales_df), 2000), ] %&gt;% ggplot(aes(x = sales_amount, y = sales_unit_price * sales_quantity)) + geom_point(size = 1, alpha = 0.2) d_amt &lt;- sales_df %&gt;% mutate(out_sales = sales_unit_price * sales_quantity, res_sales = ifelse(abs(out_sales - sales_amount) &lt; 10, &quot;pass&quot;, &#39;fail&#39;), out_cost = sales_unit_cost * sales_quantity, res_cost = ifelse(abs(out_cost - total_cost) &lt; 10, &quot;pass&quot;, &#39;fail&#39;)) %&gt;% dplyr::filter(res_sales == &quot;fail&quot; | res_cost == &quot;fail&quot;) anti_join(v_amt, d_amt) &gt; # A tibble: 0 x 27 &gt; # ... with 27 variables: sales_unit_price &lt;dbl&gt;, sales_quantity &lt;dbl&gt;, &gt; # sales_amount &lt;dbl&gt;, sales_unit_cost &lt;dbl&gt;, total_cost &lt;dbl&gt;, &gt; # return_quantity &lt;dbl&gt;, return_amount &lt;dbl&gt;, discount_quantity &lt;dbl&gt;, &gt; # discount_amount &lt;dbl&gt;, discount_percent &lt;dbl&gt;, promotion_name &lt;chr&gt;, &gt; # start_date &lt;dttm&gt;, end_date &lt;dttm&gt;, channel_name &lt;chr&gt;, store_type &lt;chr&gt;, &gt; # store_name &lt;chr&gt;, status &lt;chr&gt;, employee_count &lt;dbl&gt;, &gt; # selling_area_size &lt;dbl&gt;, continent_name &lt;chr&gt;, ... d_amt %&gt;% transmute(diff_sales = sales_unit_price * sales_quantity - sales_amount, diff_cost = sales_unit_cost * sales_quantity - total_cost) %&gt;% summarise(diff_total_sales = sum(diff_sales), diff_total_cost = sum(diff_cost)) &gt; # A tibble: 1 x 2 &gt; diff_total_sales diff_total_cost &gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 7130133. 6855349. d_date &lt;- sales_df %&gt;% mutate(period = end_date - start_date) %&gt;% dplyr::filter(period &gt; 365) anti_join(v_date, d_date) &gt; # A tibble: 0 x 27 &gt; # ... with 27 variables: sales_unit_price &lt;dbl&gt;, sales_quantity &lt;dbl&gt;, &gt; # sales_amount &lt;dbl&gt;, sales_unit_cost &lt;dbl&gt;, total_cost &lt;dbl&gt;, &gt; # return_quantity &lt;dbl&gt;, return_amount &lt;dbl&gt;, discount_quantity &lt;dbl&gt;, &gt; # discount_amount &lt;dbl&gt;, discount_percent &lt;dbl&gt;, promotion_name &lt;chr&gt;, &gt; # start_date &lt;dttm&gt;, end_date &lt;dttm&gt;, channel_name &lt;chr&gt;, store_type &lt;chr&gt;, &gt; # store_name &lt;chr&gt;, status &lt;chr&gt;, employee_count &lt;dbl&gt;, &gt; # selling_area_size &lt;dbl&gt;, continent_name &lt;chr&gt;, ... count(sales_df, status) &gt; # A tibble: 2 x 2 &gt; status n &gt; * &lt;chr&gt; &lt;int&gt; &gt; 1 Off 3090 &gt; 2 On 152642 sales_df %&gt;% dplyr::filter(status == &#39;Off&#39; &amp; (employee_count &gt; 0 | selling_area_size &gt; 0)) &gt; # A tibble: 3,090 x 27 &gt; sales_unit_price sales_quantity sales_amount sales_unit_cost total_cost &gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 15.0 180 2698. 7.64 1375. &gt; 2 25.0 360 8996. 12.7 4586. &gt; 3 120. 4 480. 61.2 245. &gt; 4 269 4 1076 137. 549. &gt; 5 76.0 4 304. 38.7 155. &gt; 6 16.9 4 67.6 8.62 34.5 &gt; 7 76.0 4 304. 38.7 155. &gt; 8 39.9 4 160. 20.3 81.4 &gt; 9 110. 4 440. 56.1 224. &gt; 10 270. 4 1080. 138. 550. &gt; # ... with 3,080 more rows, and 22 more variables: return_quantity &lt;dbl&gt;, &gt; # return_amount &lt;dbl&gt;, discount_quantity &lt;dbl&gt;, discount_amount &lt;dbl&gt;, &gt; # discount_percent &lt;dbl&gt;, promotion_name &lt;chr&gt;, start_date &lt;dttm&gt;, &gt; # end_date &lt;dttm&gt;, channel_name &lt;chr&gt;, store_type &lt;chr&gt;, store_name &lt;chr&gt;, &gt; # status &lt;chr&gt;, employee_count &lt;dbl&gt;, selling_area_size &lt;dbl&gt;, &gt; # continent_name &lt;chr&gt;, region_country_name &lt;chr&gt;, product_name &lt;chr&gt;, &gt; # product_subcategory &lt;chr&gt;, product_category &lt;chr&gt;, manufacturer &lt;chr&gt;, ... 4.2 EDA We will focus on columns of class name, product category, manufacturer, store type, and sales unit price. Columns of promotion name, start date, end date, status, channel name, brand name, and continent are left unused. 4.2.1 Categorical sales_df %&gt;% select(where(is.character)) %&gt;% skimr::skim() knitr::include_graphics(&quot;img/skim1.png&quot;) Quickly extract categorical variables with less than 10 unique values and then explore them. 1. 69% of sales is done via store across the world. 16% is done by online. Only US uses catalog. China, Germany, and US use online. 2. 50% of sales of expensive computers (50%) is from a supplier (Proseware, Inc.). sales_df %&gt;% select_if(is.character) %&gt;% gather(colvar, value) %&gt;% group_by(colvar) %&gt;% summarise(uniq = n_distinct(value)) %&gt;% dplyr::filter(uniq &lt;= 10) %&gt;% pull(colvar) %&gt;% dput() &gt; c(&quot;brand_name&quot;, &quot;channel_name&quot;, &quot;class_name&quot;, &quot;continent_name&quot;, &gt; &quot;manufacturer&quot;, &quot;product_category&quot;, &quot;promotion_name&quot;, &quot;status&quot;, &gt; &quot;store_type&quot;) sales_df %&gt;% select(c(&quot;brand_name&quot;, &quot;channel_name&quot;, &quot;class_name&quot;, &quot;continent_name&quot;, &quot;manufacturer&quot;, &quot;product_category&quot;, &quot;promotion_name&quot;, &quot;status&quot;, &quot;store_type&quot;)) %&gt;% map(table) &gt; $brand_name &gt; &gt; A. Datum Adventure Works Contoso &gt; 13979 11225 50214 &gt; Fabrikam Litware Northwind Traders &gt; 15958 3521 1905 &gt; Proseware Southridge Video The Phone Company &gt; 17719 16407 14352 &gt; Wide World Importers &gt; 10452 &gt; &gt; $channel_name &gt; &gt; Catalog Online Reseller Store &gt; 6277 24200 18035 107220 &gt; &gt; $class_name &gt; &gt; Deluxe Economy Regular &gt; 18131 54040 83561 &gt; &gt; $continent_name &gt; &gt; Asia Europe North America &gt; 44831 39907 70994 &gt; &gt; $manufacturer &gt; &gt; A. Datum Corporation Adventure Works Contoso, Ltd &gt; 13979 11225 50214 &gt; Fabrikam, Inc. Litware, Inc. Northwind Traders &gt; 15958 3521 1905 &gt; Proseware, Inc. Southridge Video The Phone Company &gt; 17719 16407 14352 &gt; Wide World Importers &gt; 10452 &gt; &gt; $product_category &gt; &gt; Audio Cameras and camcorders &gt; 7215 36375 &gt; Cell phones Computers &gt; 26893 56901 &gt; Music, Movies and Audio Books TV and Video &gt; 8385 19963 &gt; &gt; $promotion_name &gt; &gt; Asian Holiday Promotion Asian Spring Promotion &gt; 8757 10758 &gt; Asian Summer Promotion European Back-to-Scholl Promotion &gt; 4594 5983 &gt; European Holiday Promotion European Spring Promotion &gt; 16699 6537 &gt; No Discount North America Back-to-School Promotion &gt; 61480 8695 &gt; North America Holiday Promotion North America Spring Promotion &gt; 15621 16608 &gt; &gt; $status &gt; &gt; Off On &gt; 3090 152642 &gt; &gt; $store_type &gt; &gt; Catalog Online Reseller Store &gt; 6277 24200 18035 107220 prop.table(table(sales_df$channel_name, sales_df$store_type)) &gt; &gt; Catalog Online Reseller Store &gt; Catalog 0.04030642 0.00000000 0.00000000 0.00000000 &gt; Online 0.00000000 0.15539517 0.00000000 0.00000000 &gt; Reseller 0.00000000 0.00000000 0.11580793 0.00000000 &gt; Store 0.00000000 0.00000000 0.00000000 0.68849048 addmargins(table(sales_df$region_country_name, sales_df$store_type), FUN = list(Total = sum), quiet = TRUE) &gt; &gt; Catalog Online Reseller Store Total &gt; Armenia 0 0 0 850 850 &gt; Australia 0 0 0 2728 2728 &gt; Bhutan 0 0 0 979 979 &gt; Canada 0 0 0 2753 2753 &gt; China 0 9190 7311 4732 21233 &gt; Denmark 0 0 0 541 541 &gt; France 0 0 5097 3271 8368 &gt; Germany 0 8508 0 5093 13601 &gt; Greece 0 0 0 519 519 &gt; India 0 0 0 2674 2674 &gt; Iran 0 0 0 1705 1705 &gt; Ireland 0 0 0 508 508 &gt; Italy 0 0 0 1925 1925 &gt; Japan 0 0 0 5569 5569 &gt; Kyrgyzstan 0 0 0 900 900 &gt; Malta 0 0 0 514 514 &gt; Pakistan 0 0 0 1345 1345 &gt; Poland 0 0 0 579 579 &gt; Portugal 0 0 0 496 496 &gt; Romania 0 0 0 507 507 &gt; Russia 0 0 0 2222 2222 &gt; Singapore 0 0 0 930 930 &gt; Slovenia 0 0 0 536 536 &gt; South Korea 0 0 0 1220 1220 &gt; Spain 0 0 0 560 560 &gt; Sweden 0 0 0 511 511 &gt; Switzerland 0 0 0 530 530 &gt; Syria 0 0 0 1182 1182 &gt; Taiwan 0 0 0 764 764 &gt; Thailand 0 0 0 1089 1089 &gt; the Netherlands 0 0 0 537 537 &gt; Turkmenistan 0 0 0 1663 1663 &gt; United Kingdom 0 0 0 7453 7453 &gt; United States 6277 6502 5627 49835 68241 &gt; Total 6277 24200 18035 107220 155732 ftable(xtabs(~ product_category + class_name, data = sales_df)) &gt; class_name Deluxe Economy Regular &gt; product_category &gt; Audio 923 4393 1899 &gt; Cameras and camcorders 4277 10561 21537 &gt; Cell phones 4495 6011 16387 &gt; Computers 5164 24751 26986 &gt; Music, Movies and Audio Books 2769 1657 3959 &gt; TV and Video 503 6667 12793 ftable(table(sales_df$manufacturer, sales_df$product_category, sales_df$class_name)) &gt; Deluxe Economy Regular &gt; &gt; A. Datum Corporation Audio 0 0 0 &gt; Cameras and camcorders 1697 2996 9286 &gt; Cell phones 0 0 0 &gt; Computers 0 0 0 &gt; Music, Movies and Audio Books 0 0 0 &gt; TV and Video 0 0 0 &gt; Adventure Works Audio 0 0 0 &gt; Cameras and camcorders 0 0 0 &gt; Cell phones 0 0 0 &gt; Computers 849 2571 4214 &gt; Music, Movies and Audio Books 0 0 0 &gt; TV and Video 221 1573 1797 &gt; Contoso, Ltd Audio 643 1609 759 &gt; Cameras and camcorders 824 4618 3222 &gt; Cell phones 1550 4142 6849 &gt; Computers 942 9445 6100 &gt; Music, Movies and Audio Books 1401 839 1967 &gt; TV and Video 0 951 4353 &gt; Fabrikam, Inc. Audio 0 0 0 &gt; Cameras and camcorders 1756 2947 9029 &gt; Cell phones 0 0 0 &gt; Computers 0 294 1932 &gt; Music, Movies and Audio Books 0 0 0 &gt; TV and Video 0 0 0 &gt; Litware, Inc. Audio 0 0 0 &gt; Cameras and camcorders 0 0 0 &gt; Cell phones 0 0 0 &gt; Computers 0 0 0 &gt; Music, Movies and Audio Books 0 0 0 &gt; TV and Video 39 1142 2340 &gt; Northwind Traders Audio 0 1609 296 &gt; Cameras and camcorders 0 0 0 &gt; Cell phones 0 0 0 &gt; Computers 0 0 0 &gt; Music, Movies and Audio Books 0 0 0 &gt; TV and Video 0 0 0 &gt; Proseware, Inc. Audio 0 0 0 &gt; Cameras and camcorders 0 0 0 &gt; Cell phones 0 0 0 &gt; Computers 2534 4955 10230 &gt; Music, Movies and Audio Books 0 0 0 &gt; TV and Video 0 0 0 &gt; Southridge Video Audio 0 0 0 &gt; Cameras and camcorders 0 0 0 &gt; Cell phones 0 0 0 &gt; Computers 64 4212 406 &gt; Music, Movies and Audio Books 1368 818 1992 &gt; TV and Video 243 3001 4303 &gt; The Phone Company Audio 0 0 0 &gt; Cameras and camcorders 0 0 0 &gt; Cell phones 2945 1869 9538 &gt; Computers 0 0 0 &gt; Music, Movies and Audio Books 0 0 0 &gt; TV and Video 0 0 0 &gt; Wide World Importers Audio 280 1175 844 &gt; Cameras and camcorders 0 0 0 &gt; Cell phones 0 0 0 &gt; Computers 775 3274 4104 &gt; Music, Movies and Audio Books 0 0 0 &gt; TV and Video 0 0 0 Plot categorical variables based on frequency count. Refer to ggplot2: elegant graphics for data analysis to learn how to plot. sales_df%&gt;% ggplot(aes(x = class_name, fill = class_name)) + geom_bar(width = .2, show.legend = FALSE) + geom_text(aes(label = ..count..), stat = &quot;count&quot;, vjust = 1.5) + scale_y_continuous(labels = scales::comma) + labs(x = NULL, y = NULL) sales_df %&gt;% count(product_category, class_name, manufacturer, store_type) %&gt;% pivot_longer(-n, names_to = &quot;var&quot;, values_to = &quot;val&quot;) %&gt;% mutate(val = tidytext::reorder_within(val, n, var, sum)) %&gt;% ggplot(aes(n, val)) + geom_col() + tidytext::scale_y_reordered() + facet_wrap(~var, scales = &#39;free_y&#39;) + labs(x = NULL, y = NULL) Reshape the data from a long format to a wide format. filter data based on the specified conditions and count a variable. sales_df %&gt;% count(class_name, product_category, manufacturer, store_type) %&gt;% spread(store_type, n, fill = 0) &gt; # A tibble: 57 x 7 &gt; class_name product_category manufacturer Catalog Online Reseller Store &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Deluxe Audio Contoso, Ltd 20 80 55 488 &gt; 2 Deluxe Audio Wide World I~ 12 46 50 172 &gt; 3 Deluxe Cameras and camcorders A. Datum Cor~ 66 230 173 1228 &gt; 4 Deluxe Cameras and camcorders Contoso, Ltd 37 133 114 540 &gt; 5 Deluxe Cameras and camcorders Fabrikam, In~ 74 276 221 1185 &gt; 6 Deluxe Cell phones Contoso, Ltd 71 243 203 1033 &gt; 7 Deluxe Cell phones The Phone Co~ 112 508 392 1933 &gt; 8 Deluxe Computers Adventure Wo~ 38 124 103 584 &gt; 9 Deluxe Computers Contoso, Ltd 41 161 151 589 &gt; 10 Deluxe Computers Proseware, I~ 92 370 282 1790 &gt; # ... with 47 more rows sales_df %&gt;% dplyr::filter(region_country_name == &#39;United States&#39;) %&gt;% count(store_name) &gt; # A tibble: 198 x 2 &gt; store_name n &gt; * &lt;chr&gt; &lt;int&gt; &gt; 1 Contoso Albany Store 280 &gt; 2 Contoso Alexandria Store 266 &gt; 3 Contoso Anchorage Store 244 &gt; 4 Contoso Annapolis Store 271 &gt; 5 Contoso Appleton Store 279 &gt; 6 Contoso Arlington Store 258 &gt; 7 Contoso Atlantic City Store 275 &gt; 8 Contoso Attleboro Store 243 &gt; 9 Contoso Aurora Store 282 &gt; 10 Contoso Austin Store 255 &gt; # ... with 188 more rows sales_df %&gt;% group_by(store_name) %&gt;% dplyr::filter(n() &gt; 8000) %&gt;% count(store_name) &gt; # A tibble: 2 x 2 &gt; # Groups: store_name [2] &gt; store_name n &gt; &lt;chr&gt; &lt;int&gt; &gt; 1 Contoso Asia Online Store 9190 &gt; 2 Contoso Europe Online Store 8508 4.2.2 Numeric This section focus on sales_unit_price. 1. sd of return_quantity, discount_quantity, and discount_percent is small. Their fraud risk is low. 2. sales_unit_price is skewed. However, it shows a normal distribution at the level product category. sales_df %&gt;% select_if(is.numeric) %&gt;% skimr::skim() %&gt;% dplyr::filter(numeric.sd &lt; 3) skimr::skim(sales_df, sales_unit_price) sales_df %&gt;% group_by(product_name) %&gt;% skimr::skim(sales_unit_price) %&gt;% dplyr::filter(numeric.sd != 0) knitr::include_graphics(&quot;img/skim2.png&quot;) Plot numeric variables. 1. There is a a linear relationship between sales unit price and sales unit cost. 2. Most of sales is below 100. Popular products have price below 500 and cost below 250. sales_df %&gt;% ggplot(aes(sales_unit_price)) + geom_histogram(aes(y = ..density..), binwidth = 35) + geom_density(color = &#39;red&#39;) + geom_rug() sales_df %&gt;% ggplot(aes(sales_unit_price, sales_unit_cost, z = sales_quantity)) + stat_summary_hex(bins = 35, alpha = 0.5) + geom_smooth() 52% of revenue comes from regular class products (Computers, Cameras and camcorders, TV and Video) with price ranging from 100 to 1,000. summarize sales unit price of different manufacturer within a class name and product category. summarize sales unit price by product name when class name is Deluxe. sales_df %&gt;% group_by(cut = cut(sales_unit_price, breaks = c(0, 1, 100, 1000, 2000, 3000)), class_name, product_category) %&gt;% summarise(total_sales_quantity = sum(sales_quantity), total_sales_amount = sum(sales_amount), cut_pct_sales_amount = round(total_sales_amount / sum(sales_df$sales_amount), 2), .groups = &#39;drop&#39;) %&gt;% arrange(-cut_pct_sales_amount) &gt; # A tibble: 41 x 6 &gt; cut class_name product_category total_sales_quan~ total_sales_amo~ &gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 (100,1e+03] Regular Computers 304943 125813827. &gt; 2 (100,1e+03] Regular Cameras and camc~ 249164 113427331. &gt; 3 (100,1e+03] Regular TV and Video 154768 67684579. &gt; 4 (2e+03,3e+03] Deluxe Computers 16579 38894182. &gt; 5 (100,1e+03] Regular Cell phones 126686 34144060. &gt; 6 (100,1e+03] Economy Computers 118495 24821503. &gt; 7 (1e+03,2e+03] Deluxe Cameras and camc~ 16204 24913696. &gt; 8 (100,1e+03] Deluxe Cameras and camc~ 33642 14400906. &gt; 9 (100,1e+03] Economy Cameras and camc~ 71316 15073062. &gt; 10 (100,1e+03] Deluxe Cell phones 40044 13470115. &gt; # ... with 31 more rows, and 1 more variable: cut_pct_sales_amount &lt;dbl&gt; sales_df %&gt;% dplyr::filter(near(sales_unit_price, max(sales_unit_price), tol = sd(sales_unit_price))) &gt; # A tibble: 66 x 27 &gt; sales_unit_price sales_quantity sales_amount sales_unit_cost total_cost &gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 2900. 9 24360. 961. 8647. &gt; 2 2900. 10 29000. 961. 9608. &gt; 3 2900. 6 17400. 961. 5765. &gt; 4 2900. 6 17400. 961. 5765. &gt; 5 2900. 20 58000. 961. 19216. &gt; 6 2900. 6 16820. 961. 5765. &gt; 7 2900. 10 29000. 961. 8647. &gt; 8 2900. 6 17110. 961. 5765. &gt; 9 2900. 6 16240. 961. 5765. &gt; 10 2900. 30 87000. 961. 27864. &gt; # ... with 56 more rows, and 22 more variables: return_quantity &lt;dbl&gt;, &gt; # return_amount &lt;dbl&gt;, discount_quantity &lt;dbl&gt;, discount_amount &lt;dbl&gt;, &gt; # discount_percent &lt;dbl&gt;, promotion_name &lt;chr&gt;, start_date &lt;dttm&gt;, &gt; # end_date &lt;dttm&gt;, channel_name &lt;chr&gt;, store_type &lt;chr&gt;, store_name &lt;chr&gt;, &gt; # status &lt;chr&gt;, employee_count &lt;dbl&gt;, selling_area_size &lt;dbl&gt;, &gt; # continent_name &lt;chr&gt;, region_country_name &lt;chr&gt;, product_name &lt;chr&gt;, &gt; # product_subcategory &lt;chr&gt;, product_category &lt;chr&gt;, manufacturer &lt;chr&gt;, ... sales_df %&gt;% dplyr::filter(between(sales_unit_price, 0, 1)) &gt; # A tibble: 318 x 27 &gt; sales_unit_price sales_quantity sales_amount sales_unit_cost total_cost &gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 0.95 26 24.7 0.48 12.5 &gt; 2 0.95 13 12.4 0.48 6.24 &gt; 3 0.95 18 17.1 0.48 8.64 &gt; 4 0.95 18 17.1 0.48 8.64 &gt; 5 0.95 18 17.1 0.48 8.64 &gt; 6 0.95 24 21.1 0.48 11.5 &gt; 7 0.95 36 33.8 0.48 17.3 &gt; 8 0.95 9 8.55 0.48 3.84 &gt; 9 0.95 24 22.8 0.48 11.5 &gt; 10 0.95 18 17.1 0.48 8.64 &gt; # ... with 308 more rows, and 22 more variables: return_quantity &lt;dbl&gt;, &gt; # return_amount &lt;dbl&gt;, discount_quantity &lt;dbl&gt;, discount_amount &lt;dbl&gt;, &gt; # discount_percent &lt;dbl&gt;, promotion_name &lt;chr&gt;, start_date &lt;dttm&gt;, &gt; # end_date &lt;dttm&gt;, channel_name &lt;chr&gt;, store_type &lt;chr&gt;, store_name &lt;chr&gt;, &gt; # status &lt;chr&gt;, employee_count &lt;dbl&gt;, selling_area_size &lt;dbl&gt;, &gt; # continent_name &lt;chr&gt;, region_country_name &lt;chr&gt;, product_name &lt;chr&gt;, &gt; # product_subcategory &lt;chr&gt;, product_category &lt;chr&gt;, manufacturer &lt;chr&gt;, ... sales_df %&gt;% transmute(new_number = 1000 *(sales_unit_price %/% 1000)) %&gt;% count(new_number) &gt; # A tibble: 3 x 2 &gt; new_number n &gt; * &lt;dbl&gt; &lt;int&gt; &gt; 1 0 150875 &gt; 2 1000 3349 &gt; 3 2000 1508 sales_df %&gt;% group_by(class_name, product_category, manufacturer, store_type) %&gt;% summarise(across(c(sales_unit_price), tibble::lst(first, last, min, max, mean, median))) &gt; # A tibble: 228 x 10 &gt; # Groups: class_name, product_category, manufacturer [57] &gt; class_name product_category manufacturer store_type sales_unit_price~ &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &gt; 1 Deluxe Audio Contoso, Ltd Catalog 299. &gt; 2 Deluxe Audio Contoso, Ltd Online 299. &gt; 3 Deluxe Audio Contoso, Ltd Reseller 299. &gt; 4 Deluxe Audio Contoso, Ltd Store 299. &gt; 5 Deluxe Audio Wide World Im~ Catalog 296 &gt; 6 Deluxe Audio Wide World Im~ Online 296 &gt; 7 Deluxe Audio Wide World Im~ Reseller 296 &gt; 8 Deluxe Audio Wide World Im~ Store 296 &gt; 9 Deluxe Cameras and camcorders A. Datum Corp~ Catalog 290 &gt; 10 Deluxe Cameras and camcorders A. Datum Corp~ Online 290 &gt; # ... with 218 more rows, and 5 more variables: sales_unit_price_last &lt;dbl&gt;, &gt; # sales_unit_price_min &lt;dbl&gt;, sales_unit_price_max &lt;dbl&gt;, &gt; # sales_unit_price_mean &lt;dbl&gt;, sales_unit_price_median &lt;dbl&gt; sales_df %&gt;% group_by(product_name) %&gt;% summarise(across(c(sales_unit_price), tibble::lst(min, max, mean, median)), total_price_sales_amount = sum(sales_amount[sales_unit_price &gt; median(sales_unit_price)]), total_class_sales_amount = sum(sales_amount[class_name == &#39;Deluxe&#39;])) &gt; # A tibble: 1,689 x 7 &gt; product_name sales_unit_price~ sales_unit_price~ sales_unit_price~ &gt; * &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 A. Datum Advanced Digi~ 188. 188. 188. &gt; 2 A. Datum Advanced Digi~ 188. 188. 188. &gt; 3 A. Datum Advanced Digi~ 188. 188. 188. &gt; 4 A. Datum Advanced Digi~ 188. 188. 188. &gt; 5 A. Datum Advanced Digi~ 188. 188. 188. &gt; 6 A. Datum Advanced Digi~ 188. 188. 188. &gt; 7 A. Datum Advanced Digi~ 188. 188. 188. &gt; 8 A. Datum All in One Di~ 188 188 188 &gt; 9 A. Datum All in One Di~ 188 188 188 &gt; 10 A. Datum All in One Di~ 188 188 188 &gt; # ... with 1,679 more rows, and 3 more variables: &gt; # sales_unit_price_median &lt;dbl&gt;, total_price_sales_amount &lt;dbl&gt;, &gt; # total_class_sales_amount &lt;dbl&gt; sales_df %&gt;% dplyr::filter(class_name == &quot;Deluxe&quot;, product_category == &quot;Cameras and camcorders&quot;, manufacturer == &quot;Fabrikam, Inc.&quot;, store_type == &#39;Store&#39;) &gt; # A tibble: 1,185 x 27 &gt; sales_unit_price sales_quantity sales_amount sales_unit_cost total_cost &gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 657 13 8541 218. 2830. &gt; 2 645 8 5160 214. 1710. &gt; 3 657 8 5256 218. 1741. &gt; 4 657 8 5256 218. 1741. &gt; 5 645 8 5160 214. 1710. &gt; 6 657 13 8541 218. 2830. &gt; 7 1560 8 12480 517. 4135. &gt; 8 1560 8 12480 517. 4135. &gt; 9 645 8 4773 214. 1710. &gt; 10 645 8 4773 214. 1710. &gt; # ... with 1,175 more rows, and 22 more variables: return_quantity &lt;dbl&gt;, &gt; # return_amount &lt;dbl&gt;, discount_quantity &lt;dbl&gt;, discount_amount &lt;dbl&gt;, &gt; # discount_percent &lt;dbl&gt;, promotion_name &lt;chr&gt;, start_date &lt;dttm&gt;, &gt; # end_date &lt;dttm&gt;, channel_name &lt;chr&gt;, store_type &lt;chr&gt;, store_name &lt;chr&gt;, &gt; # status &lt;chr&gt;, employee_count &lt;dbl&gt;, selling_area_size &lt;dbl&gt;, &gt; # continent_name &lt;chr&gt;, region_country_name &lt;chr&gt;, product_name &lt;chr&gt;, &gt; # product_subcategory &lt;chr&gt;, product_category &lt;chr&gt;, manufacturer &lt;chr&gt;, ... 4.3 Business ananlysis 4.3.1 Product profit margin There is no unusual profit margin for each product name in the cases of return or discount. Profit margin percentage (average 50%) of each product name remains unchanged within each country. Top 5 the most sold products only take 1% of revenue. There is no concentration risk. Top 3 sales amount of product name from each product category. summarize the whole dataset based on class name, product category, manufacturer, store type. sales_df %&gt;% dplyr::filter(discount_quantity &gt; 0, return_quantity &gt; 0) %&gt;% mutate(pm_pct = (sales_unit_price - sales_unit_cost) / sales_unit_price) %&gt;% group_by(product_name) %&gt;% summarise(across(c(discount_quantity, discount_amount, return_quantity, return_amount, sales_quantity, sales_amount), sum), discount_amount_pct = discount_amount / sales_amount, return_amount_pct = return_amount / sales_amount, avg_pm_pct = mean(pm_pct)) &gt; # A tibble: 1,680 x 10 &gt; product_name discount_quanti~ discount_amount return_quantity return_amount &gt; * &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 A. Datum Adva~ 52 1480. 19 3582. &gt; 2 A. Datum Adva~ 72 1823. 26 4901 &gt; 3 A. Datum Adva~ 62 1638. 22 4147 &gt; 4 A. Datum Adva~ 72 1840. 25 4712. &gt; 5 A. Datum Adva~ 52 1529. 21 3958. &gt; 6 A. Datum Adva~ 87 2132. 27 5090. &gt; 7 A. Datum Adva~ 81 1942. 27 5090. &gt; 8 A. Datum All ~ 12 226. 4 752 &gt; 9 A. Datum All ~ 29 726. 16 3008 &gt; 10 A. Datum All ~ 39 996. 14 2632 &gt; # ... with 1,670 more rows, and 5 more variables: sales_quantity &lt;dbl&gt;, &gt; # sales_amount &lt;dbl&gt;, discount_amount_pct &lt;dbl&gt;, return_amount_pct &lt;dbl&gt;, &gt; # avg_pm_pct &lt;dbl&gt; sales_df %&gt;% mutate(pm_pct = (sales_unit_price - sales_unit_cost) / sales_unit_price) %&gt;% group_by(product_name, region_country_name) %&gt;% summarise(across(c(pm_pct), tibble::lst(min, max, mean, median))) %&gt;% dplyr::filter(pm_pct_min != pm_pct_max, pm_pct_mean != pm_pct_median) &gt; # A tibble: 0 x 6 &gt; # Groups: product_name [0] &gt; # ... with 6 variables: product_name &lt;chr&gt;, region_country_name &lt;chr&gt;, &gt; # pm_pct_min &lt;dbl&gt;, pm_pct_max &lt;dbl&gt;, pm_pct_mean &lt;dbl&gt;, pm_pct_median &lt;dbl&gt; sales_df %&gt;% mutate(pm_pct = (sales_unit_price - sales_unit_cost) / sales_unit_price) %&gt;% mutate(product = fct_lump(product_name, 5)) %&gt;% group_by(product) %&gt;% summarise(across(c(sales_quantity, sales_amount), sum), avg_pm_pct = mean(pm_pct), total_sales_pct = sales_amount / sum(sales_df$sales_amount)) &gt; # A tibble: 8 x 5 &gt; product sales_quantity sales_amount avg_pm_pct total_sales_pct &gt; * &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Contoso Phone with 13-~ 2229 37369. 0.540 0.0000656 &gt; 2 Fabrikam Trendsetter 1~ 2195 2169738. 0.669 0.00381 &gt; 3 Proseware All-In-One P~ 2087 280983. 0.540 0.000493 &gt; 4 Proseware LCD17W E202 ~ 1861 236309. 0.490 0.000415 &gt; 5 SV Car Video TFT7 M700~ 2201 652008. 0.490 0.00114 &gt; 6 The Phone Company PDA ~ 2197 581941. 0.540 0.00102 &gt; 7 The Phone Company Smar~ 1684 215098. 0.490 0.000378 &gt; 8 Other 2272925 565308999. 0.545 0.993 sales_df %&gt;% mutate(pm_pct = (sales_unit_price - sales_unit_cost) / sales_unit_price) %&gt;% group_by(product_category, product_name) %&gt;% summarise(across(c(sales_quantity, sales_amount), sum), avg_pm_pct = mean(pm_pct)) %&gt;% slice_max(order_by = sales_amount, n = 3) &gt; # A tibble: 18 x 5 &gt; # Groups: product_category [6] &gt; product_category product_name sales_quantity sales_amount avg_pm_pct &gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Audio &quot;Contoso 8GB Cloc~ 2045 604561. 0.669 &gt; 2 Audio &quot;Contoso 8GB Cloc~ 1852 549003. 0.669 &gt; 3 Audio &quot;Contoso 8GB Cloc~ 1793 531711. 0.669 &gt; 4 Cameras and camcor~ &quot;Fabrikam Indepen~ 1731 2771933. 0.669 &gt; 5 Cameras and camcor~ &quot;Fabrikam Indepen~ 1525 2265750 0.669 &gt; 6 Cameras and camcor~ &quot;Fabrikam Trendse~ 2195 2169738. 0.669 &gt; 7 Cell phones &quot;Cigarette Lighte~ 26400 659352. 0.490 &gt; 8 Cell phones &quot;The Phone Compan~ 2147 637178. 0.540 &gt; 9 Cell phones &quot;The Phone Compan~ 2098 621606 0.540 &gt; 10 Computers &quot;Proseware Projec~ 1924 4773190. 0.669 &gt; 11 Computers &quot;Proseware Projec~ 1736 4292782. 0.669 &gt; 12 Computers &quot;Contoso Projecto~ 1645 3712690. 0.669 &gt; 13 Music, Movies and ~ &quot;Contoso DVD 15-I~ 1510 432433. 0.669 &gt; 14 Music, Movies and ~ &quot;SV DVD 15-Inch P~ 1490 425995. 0.669 &gt; 15 Music, Movies and ~ &quot;SV DVD 15-Inch P~ 1464 417681. 0.669 &gt; 16 TV and Video &quot;Contoso Home The~ 1653 1451764. 0.669 &gt; 17 TV and Video &quot;Contoso Home The~ 1578 1383240. 0.669 &gt; 18 TV and Video &quot;Contoso Home The~ 1494 1309052. 0.669 sales_df %&gt;% mutate(pm_pct = (sales_unit_price - sales_unit_cost) / sales_unit_price) %&gt;% group_by(class_name, product_category, manufacturer, store_type) %&gt;% summarise(across(c(sales_unit_price, pm_pct), tibble::lst(min, max)), across(c(sales_quantity, sales_amount), tibble::lst(sum)), no_of_store = n_distinct(store_name)) &gt; # A tibble: 228 x 11 &gt; # Groups: class_name, product_category, manufacturer [57] &gt; class_name product_category manufacturer store_type sales_unit_price~ &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &gt; 1 Deluxe Audio Contoso, Ltd Catalog 299. &gt; 2 Deluxe Audio Contoso, Ltd Online 299. &gt; 3 Deluxe Audio Contoso, Ltd Reseller 299. &gt; 4 Deluxe Audio Contoso, Ltd Store 299. &gt; 5 Deluxe Audio Wide World Im~ Catalog 250. &gt; 6 Deluxe Audio Wide World Im~ Online 250. &gt; 7 Deluxe Audio Wide World Im~ Reseller 250. &gt; 8 Deluxe Audio Wide World Im~ Store 250. &gt; 9 Deluxe Cameras and camcorders A. Datum Corp~ Catalog 281 &gt; 10 Deluxe Cameras and camcorders A. Datum Corp~ Online 281 &gt; # ... with 218 more rows, and 6 more variables: sales_unit_price_max &lt;dbl&gt;, &gt; # pm_pct_min &lt;dbl&gt;, pm_pct_max &lt;dbl&gt;, sales_quantity_sum &lt;dbl&gt;, &gt; # sales_amount_sum &lt;dbl&gt;, no_of_store &lt;int&gt; sales_df %&gt;% nest(data = -c(class_name, product_category, manufacturer, store_type)) %&gt;% mutate(new = map(data, ~.x[[&#39;sales_unit_price&#39;]][20])) %&gt;% unnest(new) &gt; # A tibble: 228 x 6 &gt; store_type product_category manufacturer class_name data new &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lis&gt; &lt;dbl&gt; &gt; 1 Store Cell phones The Phone Company Regular &lt;tbl~ 301 &gt; 2 Store Cell phones Contoso, Ltd Regular &lt;tbl~ 36.0 &gt; 3 Store Computers Proseware, Inc. Regular &lt;tbl~ 160 &gt; 4 Store TV and Video Adventure Works Regular &lt;tbl~ 470. &gt; 5 Store Computers Contoso, Ltd Regular &lt;tbl~ 499 &gt; 6 Store Cameras and camcorders Contoso, Ltd Economy &lt;tbl~ 40.0 &gt; 7 Store Computers Wide World Importers Economy &lt;tbl~ 129 &gt; 8 Store Cameras and camcorders Fabrikam, Inc. Regular &lt;tbl~ 334 &gt; 9 Store Cameras and camcorders A. Datum Corporation Regular &lt;tbl~ 338 &gt; 10 Store Cell phones Contoso, Ltd Economy &lt;tbl~ 15.0 &gt; # ... with 218 more rows Assume that product name containing 15-Inch will be taxed at 17%. Calculate total tax amount on the specified product name. Some of product name is longer than 80 characters. Pull out to see them fully. sales_df %&gt;% mutate(tax = ifelse(str_detect(product_name, &#39;15-Inch&#39;), sales_unit_price * .17, 0)) %&gt;% summarise(total_tax = sum(tax)) &gt; # A tibble: 1 x 1 &gt; total_tax &gt; &lt;dbl&gt; &gt; 1 33917. sales_df %&gt;% dplyr::filter(grepl(&#39;15-Inch&#39;, product_name)) %&gt;% summarise(total_tax = sum(sales_unit_price * .17)) &gt; # A tibble: 1 x 1 &gt; total_tax &gt; &lt;dbl&gt; &gt; 1 33917. sales_df %&gt;% dplyr::filter(nchar(product_name) &gt; 80) %&gt;% distinct(product_name) %&gt;% pull() &gt; [1] &quot;Proseware 23ppm Laser Printer with Wireless and Wired Network Interfaces M680 Grey&quot; &gt; [2] &quot;Proseware 23ppm Laser Printer with Wireless and Wired Network Interfaces M680 Black&quot; &gt; [3] &quot;Proseware 23ppm Laser Printer with Wireless and Wired Network Interfaces M680 White&quot; 4.3.2 Product category summarize the average of discount amount and quantity by product category. summarize data based on product category, product subcategory, product name and ggplot sale amount and total cost. sales_df %&gt;% select(product_category, contains(&#39;discount&#39;)) %&gt;% group_by(product_category) %&gt;% summarise(across(c(contains(&#39;discount&#39;)), mean)) &gt; # A tibble: 6 x 4 &gt; product_category discount_quanti~ discount_amount discount_percent &gt; * &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Audio 0.979 15.9 0.0806 &gt; 2 Cameras and camcorders 1.14 66.6 0.0866 &gt; 3 Cell phones 1.17 27.8 0.0868 &gt; 4 Computers 1.04 44.5 0.0814 &gt; 5 Music, Movies and Audio Boo~ 1.23 19.2 0.0939 &gt; 6 TV and Video 1.07 59.7 0.0831 product_df &lt;- sales_df %&gt;% group_by(product_category, product_subcategory, product_name) %&gt;% summarise(across(c(sales_quantity, sales_amount, total_cost, return_amount, discount_amount), sum), .groups = &#39;drop&#39;) (p1 &lt;- product_df %&gt;% ggplot(aes(sales_amount, total_cost, color = product_subcategory, size = sales_quantity)) + geom_point(alpha = .3, show.legend = FALSE) + facet_wrap(~ product_category) + scale_x_continuous(labels = scales::label_number(scale = 1e-3, accuracy = NULL, big.mark = &quot;,&quot;)) + scale_y_continuous(labels = scales::label_number(scale = 1e-3, accuracy = NULL, big.mark = &quot;,&quot;)) + expand_limits(y = 0) + labs(x = &quot;Total sales (&#39;000)&quot;, y = &quot;Total cost (&#39;000)&quot;) + theme_light()) 4.3.3 Manufactuer Identify the outlier of sales unit price based on manufacturer. summarize total sales amount and percentage of products purchased from manufacturers within each product category and ggplot barchart. sales_df %&gt;% mutate(manufacturer = fct_reorder(manufacturer, sales_unit_price)) %&gt;% ggplot(aes(sales_unit_price, manufacturer), alpha = .3) + geom_boxplot() supplier_df &lt;- sales_df %&gt;% group_by(manufacturer, product_category) %&gt;% summarise(total_sales_amount = sum(sales_amount), pct = round(total_sales_amount / sum(sales_df$sales_amount), 2), .groups = &#39;drop&#39;) %&gt;% arrange(-total_sales_amount) text_df &lt;- tibble(manufacturer = unique(supplier_df$manufacturer), total_sales_amount = 40000) (p2 &lt;- supplier_df %&gt;% mutate(manufacturer = fct_reorder(manufacturer, total_sales_amount, sum)) %&gt;% ggplot(aes(total_sales_amount, manufacturer)) + geom_col(aes(fill = product_category)) + geom_text(data = text_df, aes(label = manufacturer), hjust = 0.01) + scale_x_continuous(labels = scales::label_number(scale = 1e-3, accuracy = NULL, big.mark = &quot;,&quot;)) + scale_fill_discrete(name = &#39;&#39;) + labs(x = &quot;Total sales (&#39;000)&quot;, y = NULL) + theme_minimal() + theme(legend.position = c(0.86, 0.18), legend.background = element_rect(fill = &#39;transparent&#39;, color = NA), axis.text.y = element_blank(), plot.background = element_rect(fill = NA, colour = NA), panel.background = element_blank())) 4.3.4 Store Calculate total sales amount for each store name. ggplot employee count and selling area size to identify outlier. For instance, one small store has more than 300 staffs. Map store location across the world. staff_df &lt;- sales_df %&gt;% group_by(store_name) %&gt;% mutate(total_sales_amount = sum(sales_amount)) %&gt;% select(store_name, employee_count, selling_area_size, total_sales_amount) %&gt;% distinct(store_name, .keep_all = TRUE) %&gt;% dplyr::filter(!is.na(employee_count)) staff_df %&gt;% ggplot(aes(employee_count, selling_area_size)) + geom_point(aes(size = total_sales_amount), alpha = .3, show.legend = FALSE) + ggforce::geom_mark_ellipse(aes(filter = selling_area_size &gt; 80000, description = &quot;Typo error?&quot;)) + ggforce::geom_mark_ellipse(aes(filter = employee_count &gt; 300, description = &quot;Enquery?&quot;)) store_map &lt;- map_data(&quot;world&quot;) %&gt;% mutate(region = case_when(region == &#39;USA&#39; ~ &quot;United States&quot;, region == &#39;UK&#39; ~ &quot;United Kingdom&quot;, region == &#39;Netherlands&#39; ~ &quot;the Netherlands&quot;, TRUE ~ region)) %&gt;% left_join(sales_df %&gt;% group_by(store_name, store_type, region_country_name) %&gt;% summarise(total_sales_amount = sum(sales_amount), .groups = &#39;drop&#39;), by = c(&quot;region&quot; = &quot;region_country_name&quot;)) (p3 &lt;- store_map %&gt;% ggplot(aes(long, lat, group = group, fill = total_sales_amount)) + borders(&quot;world&quot;, colour = &quot;gray85&quot;, fill = &quot;gray80&quot;) + geom_polygon() + scale_y_continuous(limits = c(-60, 90)) + scale_fill_gradient2(high = &quot;green&quot;, low = &quot;red&quot;, mid = &quot;pink&quot;, midpoint = 18627586) + ggthemes::theme_map() + coord_fixed(1.3) + guides(fill = guide_colorbar(direction = &#39;horizontal&#39;, title.position = &quot;top&quot;, barheight = unit(0.2, &quot;cm&quot;), barwidth = unit(4, &quot;cm&quot;))) + labs(fill = &quot;Total sales&quot;)) 4.4 Info graphic library(patchwork) layout &lt;- &quot; AACCCC AACCCC BBCCCC BBCCCC &quot; (p &lt;- p3 + p2 + p1 + plot_layout(design = layout) + plot_annotation(title = &quot;Overview of business operations&quot;, subtitle = &#39;Suppliers | Products | Stores&#39;, caption = &#39;RAudit Solution LLP\\nhttps://stewartli.github.io/tailwindcss/&#39;) &amp; theme(plot.tag.position = c(0, 1), plot.tag = element_text(size = 8, hjust = 0, vjust = 0))) knitr::include_graphics(&quot;img/info_graphics.png&quot;) 4.5 Report A nice summary table and plot can be easily included in a Rmarkdown document. A final report is produced in the form of HTML, PDF, and Words. knitr::include_graphics(&quot;img/biz-report.png&quot;) 4.6 Dashboard You might be asked to make a BI dashboard which allows your users to explore data interactively. To learn more, refer to Mastering Shiny library(shiny) library(DT) library(shinyWidgets) library(bslib) library(thematic) theme_toggle &lt;- function() { div(class = &quot;custom-control custom-switch&quot;, tags$input( id = &quot;custom_mode&quot;, type = &quot;checkbox&quot;, class = &quot;custom-control-input&quot;, onclick = HTML(&quot;Shiny.setInputValue(&#39;dark_mode&#39;, document.getElementById(&#39;custom_mode&#39;).value);&quot;) ), tags$label( &quot;Mode&quot;, `for` = &quot;custom_mode&quot;, class = &quot;custom-control-label&quot;) ) } ui &lt;- fluidPage( theme_toggle(), theme = bslib::bs_theme(bootswatch = &#39;minty&#39;), sidebarLayout( sidebarPanel( width = 4, fluidRow( column(6, selectInput(&quot;productcat&quot;, &quot;Product category&quot;, unique(sales_df$product_category))), column(6, selectizeInput(&quot;region&quot;, &quot;Region&quot;, unique(sales_df$region_country_name))) ), plotOutput(&quot;topsupplier&quot;), plotOutput(&quot;storetype&quot;) ), mainPanel( width = 8, DT::DTOutput(&quot;tbl&quot;) ) ) ) server &lt;- function(input, output, session) { df &lt;- reactive({ sales_df %&gt;% dplyr::filter(product_category %in% input$productcat, region_country_name %in% input$region) }) observeEvent(input$custom_mode, { session$setCurrentTheme( if (input$custom_mode) bslib::bs_theme(bootswatch = &#39;journal&#39;) else bslib::bs_theme(bootswatch = &#39;minty&#39;) ) }) output$topsupplier &lt;- renderPlot({ df() %&gt;% group_by(manufacturer) %&gt;% summarise(n = n(), amt = sum(sales_amount)) %&gt;% slice_max(order_by = amt, n = 10) %&gt;% ggplot(aes(n, amt)) + geom_point() + scale_x_continuous(label = scales::unit_format(scale = 1e-3, unit = &quot;K&quot;)) + scale_y_continuous(label = scales::unit_format(scale = 1e-6, unit = &quot;M&quot;)) + labs(title = &quot;Top 10 supplier (Frequency vs Amount)&quot;, x = NULL, y = NULL) + theme(plot.title.position = &quot;plot&quot;) }) output$storetype &lt;- renderPlot({ df() %&gt;% group_by(store_type, class_name) %&gt;% summarise(amt = sum(sales_amount), .groups = &quot;drop&quot;) %&gt;% mutate(store_type = fct_reorder(store_type, amt)) %&gt;% ggplot(aes(store_type, amt, fill = class_name)) + geom_col() + scale_y_continuous(label = scales::unit_format(scale = 1e-6, unit = &quot;M&quot;)) + scale_fill_discrete(name = &quot;&quot;) + labs(title = &quot;Sales amount break down (Store type vs Class name)&quot;, x = NULL, y = NULL) + theme(plot.title.position = &quot;plot&quot;, legend.position = &quot;bottom&quot;, legend.direction = &quot;horizontal&quot;, legend.background = element_rect(fill = &quot;transparent&quot;)) }) output$tbl &lt;- DT::renderDT(server = FALSE, { df() %&gt;% select(product_subcategory, product_name, store_name, employee_count, selling_area_size) %&gt;% mutate(product_name = str_trunc(product_name, width = 40, ellipsis = &quot;...&quot;)) %&gt;% rename_with(function(x) str_to_title(str_replace_all(x, &quot;_&quot;, &quot; &quot;)), everything()) %&gt;% DT::datatable( caption = htmltools::tags$caption(style = &#39;caption-side: top; text-align: center;&#39;, paste0(&quot;Table: &quot;, input$productcat, &quot; in &quot;, input$region)), extensions = c(&quot;Scroller&quot;, &quot;FixedColumns&quot;, &quot;Buttons&quot;), options = list( dom = &quot;Bfrtip&quot;, pageLength = 15, buttons = c(&quot;copy&quot;, &quot;print&quot;, &quot;csv&quot;, &quot;excel&quot;, &quot;pdf&quot;) ) ) }) } thematic::thematic_shiny() shinyApp(ui, server) knitr::include_graphics(&quot;img/dashboard1.png&quot;) knitr::include_graphics(&quot;img/dashboard2.png&quot;) "],["external-auditors.html", "Chapter 5 External Auditors 5.1 Cleaning 5.2 Validation 5.3 EDA 5.4 Audit planning 5.5 Substantive test 5.6 Reporting", " Chapter 5 External Auditors This chapter is written from External Auditors perspective. Has said that, techniques can be used by other accounting professionals. External auditors usually perform audit procedures on Trial balance throughout the process from audit planning and substantive testing to reporting. Those audit procedures typically include 1) test of control; 2) identification of outlier; 3) ratios; 4) confirmation letters; 5) vouching. For illustration purpose, the audit scope is revenue and account receivables accounts. 5.1 Cleaning cells &lt;- tidyxl::xlsx_cells(here::here(&quot;data/gl_stewart.xlsx&quot;)) %&gt;% dplyr::filter(!is_blank) %&gt;% select(row, col, data_type, numeric, date, character) gl &lt;- cells %&gt;% unpivotr::behead(&quot;N&quot;, &quot;field1&quot;) %&gt;% select(-col) %&gt;% unpivotr::spatter(field1) %&gt;% select(-row) %&gt;% mutate(account = coalesce(account, bf), subaccount = coalesce(subaccount, account)) %&gt;% fill(account, .direction = &quot;down&quot;) %&gt;% fill(subaccount, .direction = &quot;down&quot;) %&gt;% select(account, subaccount, Type, Date, Num, Adj, Name, Memo, Split, Debit, Credit, Balance) %&gt;% mutate(Date = as.Date(Date, &quot;%Y-%m-%d&quot;)) %&gt;% janitor::clean_names() %&gt;% replace_na(list(debit = 0, credit = 0, balance = 0)) write.csv(gl, here::here(&quot;data/gl.csv&quot;)) 5.2 Validation Remove unused column of adj. filter out NA out of column of type as they are subtotal. Transaction dates are within the range of audit period (2018-01-01, 2018-12-31). Control totals of debit and credit is same. Data dictionary and Chart of Accounts (COA) are provided. gl_df &lt;- read_csv(here::here(&quot;data/gl.csv&quot;)) %&gt;% select(-1, -adj) %&gt;% dplyr::filter(!is.na(type)) %&gt;% mutate(weekday = lubridate::wday(date, label = TRUE), month = lubridate::month(date, label = TRUE), quarter = factor(lubridate::quarter(date))) range(gl_df$date, na.rm = TRUE) &gt; [1] &quot;2018-01-01&quot; &quot;2018-12-31&quot; gl_df %&gt;% select(debit, credit) %&gt;% colSums() &gt; debit credit &gt; 2136029 2136029 dd &lt;- tibble::tribble(~Original, ~Description, ~Rename, &quot;&quot;, &quot;Row number&quot; , &quot;id&quot;, &quot;account&quot;, &quot;Charter of Accounts&quot;, &quot;account&quot;, &quot;subaccount&quot;, &quot;Charter of Accounts&quot;, &quot;subaccount&quot;, &quot;type&quot;, &quot;Invoice/Payment&quot;, &quot;type&quot;, &quot;date&quot;, &quot;JV posting date&quot;, &quot;date&quot;, &quot;num&quot;, &quot;JV number&quot;, &quot;num&quot;, &quot;adj&quot;, &quot;JV adjustment&quot;, &quot;adj&quot;, &quot;name&quot;, &quot;Customers/Suppliers&quot;, &quot;name&quot;, &quot;memo&quot;, &quot;JV description&quot;, &quot;memo&quot;, &quot;split&quot;, &quot;JV double entries&quot;, &quot;split&quot;, &quot;debit&quot;, &quot;JV amount&quot;, &quot;debit&quot;, &quot;credit&quot;, &quot;JV amount&quot;, &quot;credit&quot;, &quot;balance&quot;, &quot;Cumulated JV amount&quot;, &quot;balance&quot;, &quot;weekday&quot;, &quot;Mutated variable&quot;, &quot;weekday&quot;, &quot;month&quot;, &quot;Mutated variable&quot;, &quot;month&quot;, &quot;quarter&quot;, &quot;Mutated variable&quot;, &quot;quarter&quot;) dd %&gt;% DT::datatable(rownames = FALSE, options = list(paging = TRUE, pageLength = 20)) library(collapsibleTree) gl_df %&gt;% collapsibleTree(hierarchy = c(&quot;account&quot;, &quot;subaccount&quot;, &quot;name&quot;), width = 800, zoomable = TRUE) 5.3 EDA Columns of split and balance are left untouched. EDA of numeric is based on revenue data. 5.3.1 Missing value gl_df %&gt;% summarise(across(everything(), ~formattable::percent(mean(is.na(.))))) %&gt;% gather() &gt; # A tibble: 14 x 2 &gt; key value &gt; &lt;chr&gt; &lt;formttbl&gt; &gt; 1 account 0.00% &gt; 2 subaccount 0.00% &gt; 3 type 0.00% &gt; 4 date 0.00% &gt; 5 num 6.81% &gt; 6 name 2.16% &gt; 7 memo 27.78% &gt; 8 split 0.00% &gt; 9 debit 0.00% &gt; 10 credit 0.00% &gt; 11 balance 0.00% &gt; 12 weekday 0.00% &gt; 13 month 0.00% &gt; 14 quarter 0.00% gl_df %&gt;% visdat::vis_miss() gl_df %&gt;% visdat::vis_dat() gl_df %&gt;% naniar::gg_miss_upset() 5.3.2 Categorical gl_df %&gt;% select(where(is.character)) %&gt;% map_dbl(~length(unique(.x))) &gt; account subaccount type num name memo split &gt; 45 62 12 615 111 411 49 See to which accounts and subaccounts most of transactions in GL are posted. actree &lt;- gl_df %&gt;% group_by(account, subaccount) %&gt;% summarise(n = n(), .groups = &quot;drop&quot;) png(filename = &quot;img/actree.png&quot;, width = 1600, height = 800) treemap::treemap(actree, index = c(&quot;account&quot;, &quot;subaccount&quot;), vSize = &quot;n&quot;, vColor = &quot;n&quot;, type = &quot;index&quot;, align.labels = list(c(&quot;center&quot;, &quot;center&quot;), c(&quot;right&quot;, &quot;bottom&quot;)), fontface.labels = c(1, 3), fontsize.labels = c(10, 8), fontcolor.labels = &quot;black&quot;, title = &quot;Charter of Accounts&quot;, fontsize.title = 12, overlap.labels = 0.5, inflate.labels = FALSE, palette = &quot;Set3&quot;, border.col = c(&quot;black&quot;, &quot;white&quot;), border.lwds = c(2, 2)) dev.off() knitr::include_graphics(&quot;img/actree.png&quot;) Prepare Trial balance and monthly financial statements out of GL, and then export them to Excel as audit working paper. tb &lt;- gl_df %&gt;% group_by(subaccount) %&gt;% summarise_at(vars(debit, credit), sum) head(tb) &gt; # A tibble: 6 x 3 &gt; subaccount debit credit &gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Accounting Fees 2544 0 &gt; 2 Accounts Payable 131032. 147729. &gt; 3 Accounts Receivable 408310. 375976. &gt; 4 Accumulated Depreciation 0 923. &gt; 5 Advertising Expense 2000 0 &gt; 6 Business License &amp; Fees 710. 0 mth_fs &lt;- gl_df %&gt;% group_by(account, subaccount, month) %&gt;% arrange(date) %&gt;% slice(n()) %&gt;% ungroup() %&gt;% select(account, subaccount, month, balance) %&gt;% pivot_wider(names_from = month, values_from = balance, values_fill = 0) head(mth_fs) &gt; # A tibble: 6 x 14 &gt; account subaccount Jan Feb Mar Apr May Jun Jul Aug &gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Accoun~ Accounts ~ -3.59e4 -45421 -21732. -23299 -3916. -6852. -4067. -4392. &gt; 2 Accoun~ Accounts ~ 2.24e4 10455. 16399. 16583. 21162. 26078. 38024. 43078. &gt; 3 Accumu~ Accumulat~ -7.69e1 -154. -231. -308. -385. -462. -538. -615. &gt; 4 Advert~ Advertisi~ 5 e2 0 0 1000 0 0 1500 0 &gt; 5 Busine~ Business ~ 0 710. 0 0 0 0 0 0 &gt; 6 Car/Tr~ Car Lease 5.63e2 1126 1689 2252 2815 3378 3941 4504 &gt; # ... with 4 more variables: Sep &lt;dbl&gt;, Oct &lt;dbl&gt;, Nov &lt;dbl&gt;, Dec &lt;dbl&gt; library(openxlsx) ls_df &lt;- list(&quot;TB&quot; = tb, &quot;Budget&quot; = mth_fs) write.xlsx(ls_df, file = &quot;supplements/accountant.xlsx&quot;) knitr::include_graphics(&quot;img/excel_tb1.png&quot;) knitr::include_graphics(&quot;img/excel_tb2.png&quot;) count columns of type and month. summarize debit and credit for each type. gl_df %&gt;% count(type, sort = TRUE) &gt; # A tibble: 12 x 2 &gt; type n &gt; &lt;chr&gt; &lt;int&gt; &gt; 1 Invoice 2632 &gt; 2 Paycheck 1246 &gt; 3 Check 559 &gt; 4 Payment 176 &gt; 5 Bill 166 &gt; 6 Deposit 111 &gt; 7 Liability Check 111 &gt; 8 Bill Pmt -Check 84 &gt; 9 General Journal 72 &gt; 10 Credit Card Charge 68 &gt; 11 Transfer 14 &gt; 12 Inventory Adjust 2 gl_df %&gt;% count(type, account, subaccount, sort = TRUE) %&gt;% slice(1:3, (n()-3):n()) &gt; # A tibble: 7 x 4 &gt; type account subaccount n &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &gt; 1 Invoice Revenue Revenue 847 &gt; 2 Invoice Inventory Asset Inventory Asset 845 &gt; 3 Invoice Purchases (Cost of Goods) Purchases (Cost of Goods) 845 &gt; 4 Paycheck Car/Truck Expense Mileage 1 &gt; 5 Paycheck Direct Labor Wages - Sales-Inside 1 &gt; 6 Paycheck Wages Employee Bonus 1 &gt; 7 Paycheck Wages Sick/Holiday &amp; Vacation Pay 1 gl_df %&gt;% group_by(type) %&gt;% summarise(across(c(debit, credit), sum)) &gt; # A tibble: 12 x 3 &gt; type debit credit &gt; * &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Bill 147803. 147803. &gt; 2 Bill Pmt -Check 131032. 131032. &gt; 3 Check 216938. 216938. &gt; 4 Credit Card Charge 3454. 3454. &gt; 5 Deposit 375976. 375976. &gt; 6 General Journal 9007. 9007. &gt; 7 Inventory Adjust 375 375 &gt; 8 Invoice 585165. 585165. &gt; 9 Liability Check 12728. 12728. &gt; 10 Paycheck 147576. 147576. &gt; 11 Payment 375976. 375976. &gt; 12 Transfer 130000 130000 table(gl_df$type, gl_df$month) %&gt;% addmargins() &gt; &gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov &gt; Bill 32 19 11 25 4 8 6 9 15 7 9 &gt; Bill Pmt -Check 0 12 12 8 10 6 8 6 2 10 6 &gt; Check 56 49 35 54 45 43 53 55 39 48 45 &gt; Credit Card Charge 6 6 4 10 4 2 6 4 8 6 8 &gt; Deposit 8 10 11 5 12 15 0 16 11 8 0 &gt; General Journal 4 6 6 6 6 6 6 6 6 6 6 &gt; Inventory Adjust 0 0 0 0 0 0 0 0 0 0 0 &gt; Invoice 197 230 175 218 374 348 312 220 113 73 166 &gt; Liability Check 0 9 9 9 16 2 9 9 9 9 9 &gt; Paycheck 40 104 103 101 103 105 104 103 108 107 100 &gt; Payment 6 14 16 20 12 16 16 14 18 12 20 &gt; Transfer 0 2 2 0 2 2 2 2 0 0 2 &gt; Sum 349 461 384 456 588 553 522 444 329 286 371 &gt; &gt; Dec Sum &gt; Bill 21 166 &gt; Bill Pmt -Check 4 84 &gt; Check 37 559 &gt; Credit Card Charge 4 68 &gt; Deposit 15 111 &gt; General Journal 8 72 &gt; Inventory Adjust 2 2 &gt; Invoice 206 2632 &gt; Liability Check 21 111 &gt; Paycheck 168 1246 &gt; Payment 12 176 &gt; Transfer 0 14 &gt; Sum 498 5241 table(gl_df$type, gl_df$month) %&gt;% margin.table(2) &gt; &gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec &gt; 349 461 384 456 588 553 522 444 329 286 371 498 table(gl_df$month) &gt; &gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec &gt; 349 461 384 456 588 553 522 444 329 286 371 498 mytable &lt;- table(gl_df$quarter) lbls &lt;- paste(names(mytable), &quot;\\n&quot;, mytable, sep = &quot;&quot;) pie(mytable, labels = lbls, main = &quot;Number of transactions\\n (for each quarter)&quot;) mosaicplot(~ month + weekday, data = gl_df, color = TRUE, las = 1, main = NULL, xlab = &quot;&quot;, ylab = &quot;&quot;) Perform text analysis on the column of memo in terms of PCA and correlation. summary(nchar(gl_df$memo)) &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s &gt; 3.00 17.00 38.00 37.84 50.00 96.00 1456 gl_df %&gt;% dplyr::filter(!is.na(memo), nchar(memo) &gt; 95) %&gt;% pull(memo) &gt; [1] &quot;Commission on sales of $79,815.90 (see report) x 5%. January - June 2007. Based on a cash basis.&quot; library(tidytext) library(wordcloud2) txt &lt;- gl_df %&gt;% tidytext::unnest_tokens(word, memo) %&gt;% anti_join(stop_words) %&gt;% dplyr::filter(!str_detect(word, &quot;[0-9]&quot;)) txt %&gt;% count(word, sort = TRUE) %&gt;% wordcloud2::wordcloud2() library(widyr) txt_pca &lt;- txt %&gt;% mutate(value = 1) %&gt;% widyr::widely_svd(word, name, word, nv = 6) txt_pca %&gt;% dplyr::filter(dimension == 1) %&gt;% arrange(desc(value)) &gt; # A tibble: 262 x 3 &gt; word dimension value &gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &gt; 1 lanterns 1 0.172 &gt; 2 opal 1 0.169 &gt; 3 glass 1 0.168 &gt; 4 med 1 0.163 &gt; 5 white 1 0.160 &gt; 6 brass 1 0.158 &gt; 7 hpf 1 0.156 &gt; 8 marble 1 0.155 &gt; 9 satin 1 0.151 &gt; 10 pendant 1 0.142 &gt; # ... with 252 more rows txt_pca %&gt;% dplyr::filter(dimension == 2) %&gt;% top_n(10, abs(value)) %&gt;% mutate(word = fct_reorder(word, value)) %&gt;% ggplot(aes(value, word)) + geom_col() library(igraph) library(ggraph) library(tidygraph) txt_cor &lt;- txt %&gt;% add_count(word) %&gt;% dplyr::filter(n &gt;= 50) %&gt;% select(name, word) %&gt;% widyr::pairwise_cor(word, name, sort = TRUE) %&gt;% dplyr::filter(correlation &lt; 1) %&gt;% head(100) txt_cor %&gt;% igraph::graph_from_data_frame() %&gt;% ggraph::ggraph(layout = &#39;kk&#39;) + ggraph::geom_edge_link() + ggraph::geom_node_point() + ggraph::geom_node_text(aes(label = name), repel = TRUE) + theme_void() 5.3.3 Numberic revenue &lt;- gl_df[gl_df$subaccount == &#39;Revenue&#39;, ] The column of credit has no debit balance in this case. But, it has 0 credit amount, which could be an error. sapply(revenue, function(x) length(which(x == 0))) &gt; account subaccount type date num name memo &gt; 0 0 0 0 0 0 0 &gt; split debit credit balance weekday month quarter &gt; 0 847 5 0 0 0 0 revenue %&gt;% map_df(~sum(.x == 0)) &gt; # A tibble: 1 x 14 &gt; account subaccount type date num name memo split debit credit balance &gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &gt; 1 0 0 0 0 0 0 0 0 847 5 0 &gt; # ... with 3 more variables: weekday &lt;int&gt;, month &lt;int&gt;, quarter &lt;int&gt; revenue %&gt;% map_df(~mean(.x == 0)) &gt; # A tibble: 1 x 14 &gt; account subaccount type date num name memo split debit credit balance &gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 0 0 0 0 0 0 0 0 1 0.00590 0 &gt; # ... with 3 more variables: weekday &lt;dbl&gt;, month &lt;dbl&gt;, quarter &lt;dbl&gt; revenue %&gt;% dplyr::filter(debit == 0, credit == 0) &gt; # A tibble: 5 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-11-29 71123 Kern L~ 18x8x1~ Acco~ 0 0 &gt; 2 Revenue Revenue Invoice 2018-11-29 71123 Kern L~ Burnis~ Acco~ 0 0 &gt; 3 Revenue Revenue Invoice 2018-11-29 71123 Kern L~ Tapest~ Acco~ 0 0 &gt; 4 Revenue Revenue Invoice 2018-12-03 71139 Lavery~ Cand. ~ Acco~ 0 0 &gt; 5 Revenue Revenue Invoice 2018-12-15 71140 Thomps~ Fluore~ Acco~ 0 0 &gt; # ... with 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, month &lt;ord&gt;, &gt; # quarter &lt;fct&gt; revenue %&gt;% dplyr::filter(across(c(debit, credit), ~.x == 0)) &gt; # A tibble: 5 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-11-29 71123 Kern L~ 18x8x1~ Acco~ 0 0 &gt; 2 Revenue Revenue Invoice 2018-11-29 71123 Kern L~ Burnis~ Acco~ 0 0 &gt; 3 Revenue Revenue Invoice 2018-11-29 71123 Kern L~ Tapest~ Acco~ 0 0 &gt; 4 Revenue Revenue Invoice 2018-12-03 71139 Lavery~ Cand. ~ Acco~ 0 0 &gt; 5 Revenue Revenue Invoice 2018-12-15 71140 Thomps~ Fluore~ Acco~ 0 0 &gt; # ... with 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, month &lt;ord&gt;, &gt; # quarter &lt;fct&gt; Analyze revenue at the level of month based on both frequency and amount. # by(revenue, revenue$month, summary) table(revenue$month) %&gt;% prop.table() &gt; &gt; Jan Feb Mar Apr May Jun Jul &gt; 0.07438017 0.08736718 0.06611570 0.08264463 0.14285714 0.13341204 0.11924439 &gt; Aug Sep Oct Nov Dec &gt; 0.08382527 0.04250295 0.02715466 0.06257379 0.07792208 ggplot(revenue) + geom_bar(aes(x = factor(month), y = after_stat(count / sum(count)))) + scale_y_continuous(labels = scales::percent, name = &quot;Proportion&quot;) + labs(x = &quot;&quot;, y = &quot;&quot;) + theme_light() revenue %&gt;% ggplot(aes(month, credit)) + geom_bar(stat = &#39;summary&#39;, fun = &quot;median&quot;, fill = &#39;steelblue&#39;) + geom_label(stat = &quot;count&quot;, aes(y = ..count.., label = ..count..)) + scale_y_continuous(breaks = seq(0, 600, by = 100), labels = scales::comma) + labs(x = &quot;&quot;, y = &quot;&quot;) + theme_light() with(revenue, tapply(credit, month, function(x) {c(min(x) , max(x))})) &gt; $Jan &gt; [1] 4.95 8400.00 &gt; &gt; $Feb &gt; [1] 4.95 1980.00 &gt; &gt; $Mar &gt; [1] 9.9 5600.0 &gt; &gt; $Apr &gt; [1] 4.95 12600.00 &gt; &gt; $May &gt; [1] 4.95 6750.00 &gt; &gt; $Jun &gt; [1] 4.95 4500.00 &gt; &gt; $Jul &gt; [1] 13.5 7875.0 &gt; &gt; $Aug &gt; [1] 19.8 5000.0 &gt; &gt; $Sep &gt; [1] 35.1 6300.0 &gt; &gt; $Oct &gt; [1] 50 6300 &gt; &gt; $Nov &gt; [1] 0 4700 &gt; &gt; $Dec &gt; [1] 0 8100 revenue %&gt;% group_by(month) %&gt;% arrange(desc(credit)) %&gt;% slice(c(1, n())) &gt; # A tibble: 24 x 14 &gt; # Groups: month [12] &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-29 71124 Kern ~ Burnis~ Acco~ 0 8.4 e3 &gt; 2 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Haloge~ Acco~ 0 4.95e0 &gt; 3 Revenue Revenue Invoice 2018-02-01 71121 Kern ~ 18x8x1~ Acco~ 0 1.98e3 &gt; 4 Revenue Revenue Invoice 2018-02-12 71088 Cole ~ Haloge~ Acco~ 0 4.95e0 &gt; 5 Revenue Revenue Invoice 2018-03-28 71125 Kern ~ Cand. ~ Acco~ 0 5.6 e3 &gt; 6 Revenue Revenue Invoice 2018-03-27 71060 Godwi~ Haloge~ Acco~ 0 9.9 e0 &gt; 7 Revenue Revenue Invoice 2018-04-13 71126 Kern ~ Golden~ Acco~ 0 1.26e4 &gt; 8 Revenue Revenue Invoice 2018-04-16 71087 Cole ~ Haloge~ Acco~ 0 4.95e0 &gt; 9 Revenue Revenue Invoice 2018-05-22 71127 Kern ~ Domes,~ Acco~ 0 6.75e3 &gt; 10 Revenue Revenue Invoice 2018-05-24 71086 Cole ~ Haloge~ Acco~ 0 4.95e0 &gt; # ... with 14 more rows, and 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, &gt; # month &lt;ord&gt;, quarter &lt;fct&gt; revenue %&gt;% group_by(month) %&gt;% summarise(monthly_sales = sum(credit), .groups = &quot;drop&quot;) %&gt;% mutate(accumlated_sales = cumsum(monthly_sales)) &gt; # A tibble: 12 x 3 &gt; month monthly_sales accumlated_sales &gt; * &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Jan 25507. 25507. &gt; 2 Feb 25795. 51302. &gt; 3 Mar 30483. 81786. &gt; 4 Apr 32325. 114111. &gt; 5 May 29839. 143950. &gt; 6 Jun 31883. 175833. &gt; 7 Jul 39460. 215294. &gt; 8 Aug 31809. 247103. &gt; 9 Sep 29191. 276294. &gt; 10 Oct 28512. 304806. &gt; 11 Nov 39128 343934. &gt; 12 Dec 67876. 411810. Analyze revenue at the level of weekday based on both frequency and amount. The result indicates a cutoff problem or possible fraud as most of transactions are posted on weekends. 1. Frequency: Jan (Sun, Sat) 63% and Dec (Sat) 62%. 2. Amount: Jan (Sun, Sat) 51% and Dec (Sat) 46%. with(revenue, table(month, weekday)) %&gt;% addmargins() &gt; weekday &gt; month Sun Mon Tue Wed Thu Fri Sat Sum &gt; Jan 30 1 0 16 6 0 10 63 &gt; Feb 16 17 16 8 6 5 6 74 &gt; Mar 8 23 10 9 6 0 0 56 &gt; Apr 14 17 13 5 0 1 20 70 &gt; May 0 0 3 49 45 14 10 121 &gt; Jun 10 14 46 0 29 14 0 113 &gt; Jul 0 27 28 0 29 17 0 101 &gt; Aug 0 0 3 4 4 60 0 71 &gt; Sep 0 0 16 5 0 15 0 36 &gt; Oct 0 11 5 0 4 3 0 23 &gt; Nov 0 19 5 0 18 11 0 53 &gt; Dec 0 14 0 5 0 6 41 66 &gt; Sum 78 143 145 101 147 146 87 847 table(revenue$month, revenue$weekday) %&gt;% prop.table(margin = 1) %&gt;% round(2) %&gt;% addmargins(2) &gt; &gt; Sun Mon Tue Wed Thu Fri Sat Sum &gt; Jan 0.48 0.02 0.00 0.25 0.10 0.00 0.16 1.01 &gt; Feb 0.22 0.23 0.22 0.11 0.08 0.07 0.08 1.01 &gt; Mar 0.14 0.41 0.18 0.16 0.11 0.00 0.00 1.00 &gt; Apr 0.20 0.24 0.19 0.07 0.00 0.01 0.29 1.00 &gt; May 0.00 0.00 0.02 0.40 0.37 0.12 0.08 0.99 &gt; Jun 0.09 0.12 0.41 0.00 0.26 0.12 0.00 1.00 &gt; Jul 0.00 0.27 0.28 0.00 0.29 0.17 0.00 1.01 &gt; Aug 0.00 0.00 0.04 0.06 0.06 0.85 0.00 1.01 &gt; Sep 0.00 0.00 0.44 0.14 0.00 0.42 0.00 1.00 &gt; Oct 0.00 0.48 0.22 0.00 0.17 0.13 0.00 1.00 &gt; Nov 0.00 0.36 0.09 0.00 0.34 0.21 0.00 1.00 &gt; Dec 0.00 0.21 0.00 0.08 0.00 0.09 0.62 1.00 table(revenue$month, revenue$weekday) %&gt;% margin.table(1) &gt; &gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec &gt; 63 74 56 70 121 113 101 71 36 23 53 66 table(revenue$month, revenue$weekday) %&gt;% margin.table(2) &gt; &gt; Sun Mon Tue Wed Thu Fri Sat &gt; 78 143 145 101 147 146 87 by(revenue$month, revenue$weekday, summary) &gt; revenue$weekday: Sun &gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec &gt; 30 16 8 14 0 10 0 0 0 0 0 0 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Mon &gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec &gt; 1 17 23 17 0 14 27 0 0 11 19 14 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Tue &gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec &gt; 0 16 10 13 3 46 28 3 16 5 5 0 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Wed &gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec &gt; 16 8 9 5 49 0 0 4 5 0 0 5 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Thu &gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec &gt; 6 6 6 0 45 29 29 4 0 4 18 0 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Fri &gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec &gt; 0 5 0 1 14 14 17 60 15 3 11 6 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Sat &gt; Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec &gt; 10 6 0 20 10 0 0 0 0 0 0 41 revenue %&gt;% janitor::tabyl(month, weekday) %&gt;% janitor::adorn_totals() %&gt;% janitor::adorn_percentages(&quot;row&quot;) %&gt;% janitor::adorn_pct_formatting() %&gt;% janitor::adorn_ns(&quot;front&quot;) %&gt;% janitor::adorn_title(&quot;combined&quot;) %&gt;% janitor::adorn_rounding(digits = 0) &gt; month/weekday Sun Mon Tue Wed Thu &gt; Jan 30 (47.6%) 1 (1.6%) 0 (0.0%) 16 (25.4%) 6 (9.5%) &gt; Feb 16 (21.6%) 17 (23.0%) 16 (21.6%) 8 (10.8%) 6 (8.1%) &gt; Mar 8 (14.3%) 23 (41.1%) 10 (17.9%) 9 (16.1%) 6 (10.7%) &gt; Apr 14 (20.0%) 17 (24.3%) 13 (18.6%) 5 (7.1%) 0 (0.0%) &gt; May 0 (0.0%) 0 (0.0%) 3 (2.5%) 49 (40.5%) 45 (37.2%) &gt; Jun 10 (8.8%) 14 (12.4%) 46 (40.7%) 0 (0.0%) 29 (25.7%) &gt; Jul 0 (0.0%) 27 (26.7%) 28 (27.7%) 0 (0.0%) 29 (28.7%) &gt; Aug 0 (0.0%) 0 (0.0%) 3 (4.2%) 4 (5.6%) 4 (5.6%) &gt; Sep 0 (0.0%) 0 (0.0%) 16 (44.4%) 5 (13.9%) 0 (0.0%) &gt; Oct 0 (0.0%) 11 (47.8%) 5 (21.7%) 0 (0.0%) 4 (17.4%) &gt; Nov 0 (0.0%) 19 (35.8%) 5 (9.4%) 0 (0.0%) 18 (34.0%) &gt; Dec 0 (0.0%) 14 (21.2%) 0 (0.0%) 5 (7.6%) 0 (0.0%) &gt; Total 78 (9.2%) 143 (16.9%) 145 (17.1%) 101 (11.9%) 147 (17.4%) &gt; Fri Sat &gt; 0 (0.0%) 10 (15.9%) &gt; 5 (6.8%) 6 (8.1%) &gt; 0 (0.0%) 0 (0.0%) &gt; 1 (1.4%) 20 (28.6%) &gt; 14 (11.6%) 10 (8.3%) &gt; 14 (12.4%) 0 (0.0%) &gt; 17 (16.8%) 0 (0.0%) &gt; 60 (84.5%) 0 (0.0%) &gt; 15 (41.7%) 0 (0.0%) &gt; 3 (13.0%) 0 (0.0%) &gt; 11 (20.8%) 0 (0.0%) &gt; 6 (9.1%) 41 (62.1%) &gt; 146 (17.2%) 87 (10.3%) by(revenue$credit, revenue$weekday, summary) &gt; revenue$weekday: Sun &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. &gt; 4.95 75.60 224.00 433.91 468.75 4500.00 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Mon &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. &gt; 0.0 75.6 135.0 353.7 341.0 8400.0 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Tue &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. &gt; 9.0 84.0 180.0 511.8 405.0 7875.0 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Wed &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. &gt; 9.9 90.0 285.0 755.5 600.0 8100.0 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Thu &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. &gt; 0.0 75.6 129.6 362.0 300.0 4700.0 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Fri &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. &gt; 13.5 63.0 135.0 501.9 270.0 12600.0 &gt; ------------------------------------------------------------ &gt; revenue$weekday: Sat &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. &gt; 0.0 94.5 300.0 579.1 577.5 7000.0 psych::describeBy(revenue$credit, revenue$weekday, mat = TRUE) &gt; item group1 vars n mean sd median trimmed mad min &gt; X11 1 Sun 1 78 433.9077 684.9086 224.0 284.1289 255.7114 4.95 &gt; X12 2 Mon 1 143 353.6741 807.0311 135.0 207.3822 167.5338 0.00 &gt; X13 3 Tue 1 145 511.8241 1167.9991 180.0 247.6325 178.8016 9.00 &gt; X14 4 Wed 1 101 755.5332 1436.2487 285.0 365.9401 311.3460 9.90 &gt; X15 5 Thu 1 147 361.9544 686.0834 129.6 201.3807 158.7865 0.00 &gt; X16 6 Fri 1 146 501.9095 1359.8335 135.0 197.0905 133.4340 13.50 &gt; X17 7 Sat 1 87 579.0793 961.5876 300.0 378.8092 324.6894 0.00 &gt; max range skew kurtosis se &gt; X11 4500 4495.05 3.457969 15.017371 77.55063 &gt; X12 8400 8400.00 7.451695 67.636480 67.48733 &gt; X13 7875 7866.00 4.489303 21.141764 96.99705 &gt; X14 8100 8090.10 3.048351 9.366994 142.91209 &gt; X15 4700 4700.00 3.970806 17.436018 56.58721 &gt; X16 12600 12586.50 6.006404 44.221777 112.54062 &gt; X17 7000 7000.00 3.968410 21.091200 103.09301 xtabs(credit ~ month + weekday, revenue) %&gt;% ftable() &gt; weekday Sun Mon Tue Wed Thu Fri Sat &gt; month &gt; Jan 10827.85 8400.00 0.00 2771.95 1126.00 0.00 2381.00 &gt; Feb 4391.00 2187.45 3185.00 2991.00 6745.00 1932.00 4364.00 &gt; Mar 1872.00 7273.45 1687.95 17429.00 2221.00 0.00 0.00 &gt; Apr 2578.95 2187.45 2926.95 1563.00 0.00 12600.00 10468.95 &gt; May 0.00 0.00 8756.00 11354.90 6403.50 1637.10 1687.95 &gt; Jun 14175.00 2578.95 8279.35 0.00 5212.45 1637.10 0.00 &gt; Jul 0.00 5163.40 22491.25 0.00 3646.35 8159.25 0.00 &gt; Aug 0.00 0.00 2085.00 13300.00 8000.00 8424.45 0.00 &gt; Sep 0.00 0.00 21484.00 5569.00 0.00 2138.40 0.00 &gt; Oct 0.00 10723.60 1719.00 0.00 1714.00 14355.00 0.00 &gt; Nov 0.00 7674.00 1600.00 0.00 18139.00 11715.00 0.00 &gt; Dec 0.00 4387.10 0.00 21330.00 0.00 10680.48 31478.00 xtabs(credit ~ month + weekday, revenue) %&gt;% ftable() %&gt;% prop.table(margin = 1) %&gt;% round(2) &gt; weekday Sun Mon Tue Wed Thu Fri Sat &gt; month &gt; Jan 0.42 0.33 0.00 0.11 0.04 0.00 0.09 &gt; Feb 0.17 0.08 0.12 0.12 0.26 0.07 0.17 &gt; Mar 0.06 0.24 0.06 0.57 0.07 0.00 0.00 &gt; Apr 0.08 0.07 0.09 0.05 0.00 0.39 0.32 &gt; May 0.00 0.00 0.29 0.38 0.21 0.05 0.06 &gt; Jun 0.44 0.08 0.26 0.00 0.16 0.05 0.00 &gt; Jul 0.00 0.13 0.57 0.00 0.09 0.21 0.00 &gt; Aug 0.00 0.00 0.07 0.42 0.25 0.26 0.00 &gt; Sep 0.00 0.00 0.74 0.19 0.00 0.07 0.00 &gt; Oct 0.00 0.38 0.06 0.00 0.06 0.50 0.00 &gt; Nov 0.00 0.20 0.04 0.00 0.46 0.30 0.00 &gt; Dec 0.00 0.06 0.00 0.31 0.00 0.16 0.46 xtabs(credit ~ month + weekday, revenue) %&gt;% ftable() %&gt;% summary() &gt; V1 V2 V3 V4 &gt; Min. : 0 Min. : 0 Min. : 0 Min. : 0 &gt; 1st Qu.: 0 1st Qu.: 1641 1st Qu.: 1666 1st Qu.: 0 &gt; Median : 0 Median : 3483 Median : 2506 Median : 2881 &gt; Mean : 2820 Mean : 4215 Mean : 6185 Mean : 6359 &gt; 3rd Qu.: 3032 3rd Qu.: 7374 3rd Qu.: 8399 3rd Qu.:11841 &gt; Max. :14175 Max. :10724 Max. :22491 Max. :21330 &gt; V5 V6 V7 &gt; Min. : 0.0 Min. : 0 Min. : 0 &gt; 1st Qu.: 844.5 1st Qu.: 1637 1st Qu.: 0 &gt; Median : 2933.7 Median : 5149 Median : 0 &gt; Mean : 4433.9 Mean : 6107 Mean : 4198 &gt; 3rd Qu.: 6488.9 3rd Qu.:10939 3rd Qu.: 2877 &gt; Max. :18139.0 Max. :14355 Max. :31478 table1::table1(~credit + weekday | quarter, data = revenue) 1(N=193) 2(N=304) 3(N=208) 4(N=142) Overall(N=847) credit Mean (SD) 424 (871) 309 (907) 483 (1080) 954 (1420) 486 (1070) Median [Min, Max] 210 [4.95, 8400] 119 [4.95, 12600] 162 [13.5, 7880] 420 [0, 8100] 171 [0, 12600] weekday Sun 54 (28.0%) 24 (7.9%) 0 (0%) 0 (0%) 78 (9.2%) Mon 41 (21.2%) 31 (10.2%) 27 (13.0%) 44 (31.0%) 143 (16.9%) Tue 26 (13.5%) 62 (20.4%) 47 (22.6%) 10 (7.0%) 145 (17.1%) Wed 33 (17.1%) 54 (17.8%) 9 (4.3%) 5 (3.5%) 101 (11.9%) Thu 18 (9.3%) 74 (24.3%) 33 (15.9%) 22 (15.5%) 147 (17.4%) Fri 5 (2.6%) 29 (9.5%) 92 (44.2%) 20 (14.1%) 146 (17.2%) Sat 16 (8.3%) 30 (9.9%) 0 (0%) 41 (28.9%) 87 (10.3%) vcd::assocstats(table(revenue$month, revenue$weekday)) &gt; X^2 df P(&gt; X^2) &gt; Likelihood Ratio 1024.7 66 0 &gt; Pearson 1085.6 66 0 &gt; &gt; Phi-Coefficient : NA &gt; Contingency Coeff.: 0.749 &gt; Cramer&#39;s V : 0.462 kappa(table(revenue$month, revenue$weekday)) &gt; [1] 8.449534 library(patchwork) p1 &lt;- revenue %&gt;% mutate(weekday = fct_relevel(weekday, c(&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;))) %&gt;% group_by(month, weekday) %&gt;% count() %&gt;% ggplot(aes(month, weekday, fill = n)) + geom_tile(color = &quot;#1D2024&quot;, size = 0.5, stat = &quot;identity&quot;) + scale_fill_viridis_c(option = &quot;B&quot;) + coord_equal() + labs(x = &quot;&quot;, y = &quot;&quot;) p2 &lt;- revenue %&gt;% mutate(weekday = fct_relevel(weekday, c(&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;))) %&gt;% group_by(month, weekday) %&gt;% summarise(amt = sum(credit), .groups = &quot;drop&quot;) %&gt;% ggplot(aes(month, weekday, fill = amt)) + geom_tile(color = &quot;#1D2024&quot;, size = 0.5, stat = &quot;identity&quot;) + scale_fill_viridis_c(option = &quot;B&quot;, breaks = seq(10000, 30000, 10000), labels = c(&quot;10K&quot;, &quot;20K&quot;, &quot;30K&quot;)) + coord_equal() + labs(x = &quot;&quot;, y = &quot;&quot;) (p1/p2) + plot_layout(guide = &#39;collect&#39;) + plot_annotation(title = &quot;The number of Journal voucher posted on weekends&quot;, caption = &quot;RAudit Solution LLP\\nhttps://stewartli.github.io/tailwindcss/&quot;) &amp; theme(plot.background = element_rect(fill = &quot;#1D2024&quot;, color = &quot;#1D2024&quot;), panel.background = element_rect(fill = &quot;#1D2024&quot;, color = &quot;#1D2024&quot;), legend.background = element_rect(fill = &quot;#1D2024&quot;, color = &quot;#1D2024&quot;), text = element_text(color = &quot;#FAFAFA&quot;), axis.text = element_text(color = &quot;#FAFAFA&quot;), axis.text.x = element_text(vjust = 1), plot.title.position = &quot;plot&quot;, title = element_text(face = &quot;bold&quot;), panel.grid = element_blank(), axis.line = element_blank(), axis.ticks = element_blank(), legend.position = &quot;right&quot;, legend.title = element_blank()) knitr::include_graphics(&quot;img/calender.png&quot;) Calculate statistical descriptive summary of the column of credit. Its log10 transformation is normal distribution. psych::describe(revenue$credit) &gt; vars n mean sd median trimmed mad min max range skew kurtosis &gt; X1 1 847 486.2 1065.75 171 244.28 180.14 0 12600 12600 5.31 36.81 &gt; se &gt; X1 36.62 var(revenue$credit) &gt; [1] 1135823 quantile(revenue$credit, probs = seq(from = 0, to = 1, by = .1), na.rm = TRUE) &gt; 0% 10% 20% 30% 40% 50% 60% 70% &gt; 0.00 29.25 56.00 88.00 118.80 171.00 270.00 324.00 &gt; 80% 90% 100% &gt; 534.40 981.00 12600.00 IQR(revenue$credit) &gt; [1] 291.6 summary(revenue$credit) &gt; Min. 1st Qu. Median Mean 3rd Qu. Max. &gt; 0.0 75.6 171.0 486.2 367.2 12600.0 fivenum(revenue$credit) &gt; [1] 0.0 75.6 171.0 367.2 12600.0 revenue %&gt;% dplyr::filter(ntile(credit, 50) == 1) &gt; # A tibble: 17 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Haloge~ Acco~ 0 4.95 &gt; 2 Revenue Revenue Invoice 2018-01-31 71059 Godwi~ Haloge~ Acco~ 0 9.9 &gt; 3 Revenue Revenue Invoice 2018-02-12 71088 Cole ~ Haloge~ Acco~ 0 4.95 &gt; 4 Revenue Revenue Invoice 2018-02-27 71052 Baker~ Fluore~ Acco~ 0 9 &gt; 5 Revenue Revenue Invoice 2018-03-27 71060 Godwi~ Haloge~ Acco~ 0 9.9 &gt; 6 Revenue Revenue Invoice 2018-04-16 71087 Cole ~ Haloge~ Acco~ 0 4.95 &gt; 7 Revenue Revenue Invoice 2018-04-17 71061 Godwi~ Haloge~ Acco~ 0 9.9 &gt; 8 Revenue Revenue Invoice 2018-05-02 71062 Godwi~ Haloge~ Acco~ 0 9.9 &gt; 9 Revenue Revenue Invoice 2018-05-19 71063 Godwi~ Haloge~ Acco~ 0 9.9 &gt; 10 Revenue Revenue Invoice 2018-05-24 71086 Cole ~ Haloge~ Acco~ 0 4.95 &gt; 11 Revenue Revenue Invoice 2018-06-07 71085 Cole ~ Haloge~ Acco~ 0 4.95 &gt; 12 Revenue Revenue Invoice 2018-11-29 71123 Kern ~ 18x8x1~ Acco~ 0 0 &gt; 13 Revenue Revenue Invoice 2018-11-29 71123 Kern ~ Burnis~ Acco~ 0 0 &gt; 14 Revenue Revenue Invoice 2018-11-29 71123 Kern ~ Tapest~ Acco~ 0 0 &gt; 15 Revenue Revenue Invoice 2018-12-03 71139 Laver~ Haloge~ Acco~ 0 9.35 &gt; 16 Revenue Revenue Invoice 2018-12-03 71139 Laver~ Cand. ~ Acco~ 0 0 &gt; 17 Revenue Revenue Invoice 2018-12-15 71140 Thomp~ Fluore~ Acco~ 0 0 &gt; # ... with 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, month &lt;ord&gt;, &gt; # quarter &lt;fct&gt; revenue %&gt;% dplyr::filter(between(credit, 5000, 10000)) &gt; # A tibble: 12 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-29 71124 Kern ~ Burnis~ Acco~ 0 8400 &gt; 2 Revenue Revenue Invoice 2018-03-28 71125 Kern ~ Cand. ~ Acco~ 0 5600 &gt; 3 Revenue Revenue Invoice 2018-05-22 71127 Kern ~ Domes,~ Acco~ 0 6750 &gt; 4 Revenue Revenue Invoice 2018-07-17 71129 Kern ~ Golden~ Acco~ 0 7875 &gt; 5 Revenue Revenue Invoice 2018-08-22 71109 Dan A~ Vianne~ Acco~ 0 5000 &gt; 6 Revenue Revenue Invoice 2018-09-25 71107 Stern~ White,~ Acco~ 0 5760 &gt; 7 Revenue Revenue Invoice 2018-09-25 71107 Stern~ Sunset~ Acco~ 0 6300 &gt; 8 Revenue Revenue Invoice 2018-10-26 71108 Stern~ Sunset~ Acco~ 0 6300 &gt; 9 Revenue Revenue Invoice 2018-10-26 71108 Stern~ White,~ Acco~ 0 5760 &gt; 10 Revenue Revenue Invoice 2018-12-12 71106 Stern~ Sunset~ Acco~ 0 6300 &gt; 11 Revenue Revenue Invoice 2018-12-12 71106 Stern~ Domes,~ Acco~ 0 8100 &gt; 12 Revenue Revenue Invoice 2018-12-15 71137 Dan A~ Custom~ Acco~ 0 7000 &gt; # ... with 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, month &lt;ord&gt;, &gt; # quarter &lt;fct&gt; set.seed(2021) revenue %&gt;% slice_sample(prop = .9) %&gt;% summarise(sum(credit)) &gt; # A tibble: 1 x 1 &gt; `sum(credit)` &gt; &lt;dbl&gt; &gt; 1 379895. revenue %&gt;% ggplot(aes(sample = log10(credit))) + geom_qq() + theme_light() getPalette &lt;- colorRampPalette(RColorBrewer::brewer.pal(8, &quot;Set2&quot;))(12) lb &lt;- function(x) mean(x) - sd(x) ub &lt;- function(x) mean(x) + sd(x) df_sum &lt;- revenue %&gt;% group_by(quarter) %&gt;% summarise(across(credit, list(ymin = lb, ymax = ub, mean = mean))) revenue %&gt;% ggplot(aes(factor(quarter), credit, fill = factor(quarter))) + geom_violin(position = position_nudge(x = .2, y = 0), trim = TRUE, alpha = .8, scale = &quot;width&quot;) + geom_point(aes(y = credit, color = factor(quarter)), position = position_jitter(width = .15), size = .5, alpha = 0.8) + geom_boxplot(width = .1, outlier.shape = NA, alpha = 0.5) + geom_point(data = df_sum, aes(x = quarter, y = credit_mean), position = position_nudge(x = 0.3), size = 2.5) + geom_errorbar(data = df_sum, aes(ymin = credit_ymin, ymax = credit_ymax, y = credit_mean), position = position_nudge(x = 0.3), width = 0) + expand_limits(x = 5.25) + scale_y_continuous(labels = scales::comma) + scale_color_manual(values = getPalette) + scale_fill_manual(values = getPalette) + theme_light() + theme(legend.position = &quot;none&quot;) + labs(x = &quot;&quot;, y = &quot;&quot;) revenue %&gt;% ggplot(aes(credit, fill = factor(month))) + geom_histogram(bins = 50, alpha = .5) + geom_rug() + geom_vline(xintercept = 200, linetype = &quot;dashed&quot;, size = 1, color = &quot;red&quot;, show.legend = FALSE) + scale_x_log10(labels = scales::comma) + scale_fill_discrete(name = &quot;&quot;, guide = &quot;none&quot;) + annotate(&quot;text&quot;, x = mean(revenue$credit) * 3.6, y = 65, label = paste0(&quot;Mean: $&quot;, round(mean(revenue$credit), 2))) + labs(x = &quot;&quot;, y =&quot;&quot;) + theme_light() revenue %&gt;% mutate(weekday = fct_relevel(weekday, rev(c(&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;)))) %&gt;% ggplot(aes(credit, weekday)) + geom_boxplot(outlier.color = NA) + geom_jitter(shape = 16, position = position_jitter(0.4), alpha = .3) + stat_summary(fun = mean, geom = &quot;point&quot;, shape = 13, size = 4, color = &quot;firebrick&quot;) + scale_x_continuous(labels = scales::dollar) + theme_light() + labs(x = &quot;&quot;, y = &quot;&quot;) ml_mth &lt;- revenue %&gt;% mutate(weekday = fct_relevel(weekday, rev(c(&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;)))) %&gt;% group_by(month, weekday) %&gt;% summarise(freq = n(), amt = sum(credit)) %&gt;% mutate(cum_freq = cumsum(freq), cum_amt = cumsum(amt)) ml_mth %&gt;% ggplot(aes(amt, freq, color = amt &gt; 10000)) + geom_point() + geom_vline(xintercept = 10000, lty = 2) + ggforce::geom_mark_ellipse(data = dplyr::filter(ml_mth, freq &lt;=10, amt &gt;= 5000, amt &lt;= 10000), aes(description = &quot;Watch closely&quot;), label.fontsize = 6, label.buffer = unit(4, &#39;mm&#39;), label.fill = &quot;transparent&quot;, show.legend = FALSE) + scale_x_continuous(label = scales::comma) + scale_y_continuous(breaks = seq(0, 60, 10)) + scale_color_discrete(name = &quot;Exceed&quot;, labels = c(&quot;Yes&quot;, &quot;No&quot;), guide = FALSE) + labs(x = &quot;Total revenue&quot;, y = &quot;Number of transactions&quot;) + theme_light() 5.4 Audit planning 5.4.1 Test of controls There is no gap on journal entries (JE) numbers. revenue %&gt;% distinct(num, .keep_all = TRUE) %&gt;% arrange(num) %&gt;% mutate(gap = as.numeric(num) - dplyr::lag(as.numeric(num))) %&gt;% dplyr::filter(!is.na(gap), gap &gt; 1) &gt; # A tibble: 0 x 15 &gt; # ... with 15 variables: account &lt;chr&gt;, subaccount &lt;chr&gt;, type &lt;chr&gt;, &gt; # date &lt;date&gt;, num &lt;chr&gt;, name &lt;chr&gt;, memo &lt;chr&gt;, split &lt;chr&gt;, debit &lt;dbl&gt;, &gt; # credit &lt;dbl&gt;, balance &lt;dbl&gt;, weekday &lt;ord&gt;, month &lt;ord&gt;, quarter &lt;fct&gt;, &gt; # gap &lt;dbl&gt; filter out duplicated JE numbers. revenue %&gt;% count(num, sort = TRUE) %&gt;% add_count(n) &gt; # A tibble: 94 x 3 &gt; num n nn &gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &gt; 1 71072 17 5 &gt; 2 71085 17 5 &gt; 3 71086 17 5 &gt; 4 71087 17 5 &gt; 5 71088 17 5 &gt; 6 71073 15 11 &gt; 7 71074 15 11 &gt; 8 71075 15 11 &gt; 9 71076 15 11 &gt; 10 71077 15 11 &gt; # ... with 84 more rows revenue %&gt;% group_by(num) %&gt;% dplyr::filter(n() == 17) &gt; # A tibble: 85 x 14 &gt; # Groups: num [5] &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Die Ca~ Acco~ 0 367. &gt; 2 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Tapest~ Acco~ 0 243 &gt; 3 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Pearl ~ Acco~ 0 342 &gt; 4 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Sunset~ Acco~ 0 126 &gt; 5 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Black ~ Acco~ 0 113. &gt; 6 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Burnis~ Acco~ 0 270 &gt; 7 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Chestn~ Acco~ 0 292. &gt; 8 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Pendan~ Acco~ 0 22.5 &gt; 9 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Athena~ Acco~ 0 81 &gt; 10 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Cand. ~ Acco~ 0 50.4 &gt; # ... with 75 more rows, and 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, &gt; # month &lt;ord&gt;, quarter &lt;fct&gt; revenue$num[duplicated(revenue$num)] %&gt;% head() &gt; [1] &quot;71047&quot; &quot;71047&quot; &quot;71047&quot; &quot;71047&quot; &quot;71047&quot; &quot;71047&quot; filter JE numbers based on columns of date, name, and credit to perform Same same same/different (SSS/SSD) tests. revenue %&gt;% group_by(num, date, name, credit) %&gt;% summarise(freq = n()) %&gt;% arrange(desc(freq)) &gt; # A tibble: 817 x 5 &gt; # Groups: num, date, name [94] &gt; num date name credit freq &gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &gt; 1 71123 2018-11-29 Kern Lighting Warehouse:Store #13 0 3 &gt; 2 71052 2018-02-27 Baker&#39;s Professional Lighting:Store #15 210 2 &gt; 3 71064 2018-04-22 Godwin Lighting Depot:Store #404 75.6 2 &gt; 4 71065 2018-03-26 Godwin Lighting Depot:Store #303 75.6 2 &gt; 5 71066 2018-04-28 Godwin Lighting Depot:Store #909 75.6 2 &gt; 6 71068 2018-05-10 Godwin Lighting Depot:Store #909 75.6 2 &gt; 7 71069 2018-05-30 Godwin Lighting Depot:Store #1020 75.6 2 &gt; 8 71070 2018-06-11 Godwin Lighting Depot:Store #303 75.6 2 &gt; 9 71073 2018-08-31 Cole Home Builders:Phase 1 - Lot 5 270 2 &gt; 10 71074 2018-08-24 Cole Home Builders:Phase 1 - Lot 5 270 2 &gt; # ... with 807 more rows revenue %&gt;% dplyr::filter(num == &quot;71052&quot;, credit == 210) &gt; # A tibble: 2 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-02-27 71052 Baker&#39;~ Polish~ Acco~ 0 210 &gt; 2 Revenue Revenue Invoice 2018-02-27 71052 Baker&#39;~ 2032 S~ Acco~ 0 210 &gt; # ... with 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, month &lt;ord&gt;, &gt; # quarter &lt;fct&gt; Assume the authority limit is 5000 and filter out those transactions with credit more than the limit. revenue %&gt;% dplyr::filter(credit &gt; 5000) &gt; # A tibble: 12 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-29 71124 Kern L~ Burni~ Acco~ 0 8400 &gt; 2 Revenue Revenue Invoice 2018-03-28 71125 Kern L~ Cand.~ Acco~ 0 5600 &gt; 3 Revenue Revenue Invoice 2018-04-13 71126 Kern L~ Golde~ Acco~ 0 12600 &gt; 4 Revenue Revenue Invoice 2018-05-22 71127 Kern L~ Domes~ Acco~ 0 6750 &gt; 5 Revenue Revenue Invoice 2018-07-17 71129 Kern L~ Golde~ Acco~ 0 7875 &gt; 6 Revenue Revenue Invoice 2018-09-25 71107 Stern ~ White~ Acco~ 0 5760 &gt; 7 Revenue Revenue Invoice 2018-09-25 71107 Stern ~ Sunse~ Acco~ 0 6300 &gt; 8 Revenue Revenue Invoice 2018-10-26 71108 Stern ~ Sunse~ Acco~ 0 6300 &gt; 9 Revenue Revenue Invoice 2018-10-26 71108 Stern ~ White~ Acco~ 0 5760 &gt; 10 Revenue Revenue Invoice 2018-12-12 71106 Stern ~ Sunse~ Acco~ 0 6300 &gt; 11 Revenue Revenue Invoice 2018-12-12 71106 Stern ~ Domes~ Acco~ 0 8100 &gt; 12 Revenue Revenue Invoice 2018-12-15 71137 Dan A.~ Custo~ Acco~ 0 7000 &gt; # ... with 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, month &lt;ord&gt;, &gt; # quarter &lt;fct&gt; 5.4.2 Digits tests filter out transaction amount ending with 0.9 or divided by 1000. revenue %&gt;% dplyr::filter(near(credit - floor(credit), 0.9)) &gt; # A tibble: 10 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-31 71059 Godwi~ Broadw~ Acco~ 0 127. &gt; 2 Revenue Revenue Invoice 2018-01-31 71059 Godwi~ Haloge~ Acco~ 0 9.9 &gt; 3 Revenue Revenue Invoice 2018-03-27 71060 Godwi~ Broadw~ Acco~ 0 127. &gt; 4 Revenue Revenue Invoice 2018-03-27 71060 Godwi~ Haloge~ Acco~ 0 9.9 &gt; 5 Revenue Revenue Invoice 2018-04-17 71061 Godwi~ Broadw~ Acco~ 0 127. &gt; 6 Revenue Revenue Invoice 2018-04-17 71061 Godwi~ Haloge~ Acco~ 0 9.9 &gt; 7 Revenue Revenue Invoice 2018-05-02 71062 Godwi~ Broadw~ Acco~ 0 127. &gt; 8 Revenue Revenue Invoice 2018-05-02 71062 Godwi~ Haloge~ Acco~ 0 9.9 &gt; 9 Revenue Revenue Invoice 2018-05-19 71063 Godwi~ Broadw~ Acco~ 0 127. &gt; 10 Revenue Revenue Invoice 2018-05-19 71063 Godwi~ Haloge~ Acco~ 0 9.9 &gt; # ... with 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, month &lt;ord&gt;, &gt; # quarter &lt;fct&gt; revenue %&gt;% dplyr::filter(credit %% 1000 == 0) &gt; # A tibble: 10 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-03-12 71049 Laver~ Vianne~ Acco~ 0 1000 &gt; 2 Revenue Revenue Invoice 2018-07-13 71119 Kern ~ Burnis~ Acco~ 0 3000 &gt; 3 Revenue Revenue Invoice 2018-08-22 71109 Dan A~ Vianne~ Acco~ 0 5000 &gt; 4 Revenue Revenue Invoice 2018-11-01 71120 Kern ~ Burnis~ Acco~ 0 3000 &gt; 5 Revenue Revenue Invoice 2018-11-29 71123 Kern ~ 18x8x1~ Acco~ 0 0 &gt; 6 Revenue Revenue Invoice 2018-11-29 71123 Kern ~ Burnis~ Acco~ 0 0 &gt; 7 Revenue Revenue Invoice 2018-11-29 71123 Kern ~ Tapest~ Acco~ 0 0 &gt; 8 Revenue Revenue Invoice 2018-12-03 71139 Laver~ Cand. ~ Acco~ 0 0 &gt; 9 Revenue Revenue Invoice 2018-12-15 71137 Dan A~ Custom~ Acco~ 0 7000 &gt; 10 Revenue Revenue Invoice 2018-12-15 71140 Thomp~ Fluore~ Acco~ 0 0 &gt; # ... with 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, month &lt;ord&gt;, &gt; # quarter &lt;fct&gt; filter out same amount that appears more than 20 times. revenue %&gt;% group_by(credit) %&gt;% dplyr::filter(n() &gt; 20) &gt; # A tibble: 64 x 14 &gt; # Groups: credit [3] &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Fluore~ Acco~ 0 13.5 &gt; 2 Revenue Revenue Invoice 2018-01-28 71072 Cole ~ Specia~ Acco~ 0 19.8 &gt; 3 Revenue Revenue Invoice 2018-01-31 71059 Godwi~ Specia~ Acco~ 0 19.8 &gt; 4 Revenue Revenue Invoice 2018-01-31 71059 Godwi~ Fluore~ Acco~ 0 13.5 &gt; 5 Revenue Revenue Invoice 2018-02-12 71088 Cole ~ Fluore~ Acco~ 0 13.5 &gt; 6 Revenue Revenue Invoice 2018-02-12 71088 Cole ~ Specia~ Acco~ 0 19.8 &gt; 7 Revenue Revenue Invoice 2018-03-26 71065 Godwi~ Drop O~ Acco~ 0 75.6 &gt; 8 Revenue Revenue Invoice 2018-03-26 71065 Godwi~ Cand. ~ Acco~ 0 75.6 &gt; 9 Revenue Revenue Invoice 2018-03-26 71065 Godwi~ Fluore~ Acco~ 0 13.5 &gt; 10 Revenue Revenue Invoice 2018-03-26 71065 Godwi~ Specia~ Acco~ 0 19.8 &gt; # ... with 54 more rows, and 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, &gt; # month &lt;ord&gt;, quarter &lt;fct&gt; revenue %&gt;% group_by(credit &gt; 5000) %&gt;% summarise(across(c(credit), tibble::lst(min, max, mean, median, sum))) &gt; # A tibble: 2 x 6 &gt; `credit &gt; 5000` credit_min credit_max credit_mean credit_median credit_sum &gt; * &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 FALSE 0 5000 389. 168 325065. &gt; 2 TRUE 5600 12600 7229. 6525 86745 revenue %&gt;% group_by(credit_new = 2000 *(credit %/% 2000)) %&gt;% summarise(n = n(), total = sum(credit)) &gt; # A tibble: 6 x 3 &gt; credit_new n total &gt; * &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &gt; 1 0 801 221168. &gt; 2 2000 28 76646. &gt; 3 4000 9 44370 &gt; 4 6000 6 40525 &gt; 5 8000 2 16500 &gt; 6 12000 1 12600 revenue %&gt;% count(cut_amt = cut(credit, breaks = c(-1, 1000, 5000, 10000, 20000, max(credit)), labels = c(&quot;ML&quot;,&quot;1K&quot;,&quot;5K&quot;,&quot;10K&quot;, &quot;Outlier&quot;))) &gt; # A tibble: 4 x 2 &gt; cut_amt n &gt; * &lt;fct&gt; &lt;int&gt; &gt; 1 ML 765 &gt; 2 1K 70 &gt; 3 5K 11 &gt; 4 10K 1 5.4.3 Benfords law The result conforms to Benfords law based on frequency. library(benford.analysis) bfd.cp &lt;- benford(revenue$credit, number.of.digits = 2, sign = &quot;both&quot;, round = 3) plot(bfd.cp) getSuspects(bfd.cp, revenue, by = &quot;absolute.diff&quot;, how.many = 1) %&gt;% as_tibble() &gt; # A tibble: 29 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-03-26 71065 Godwin~ Drop ~ Acco~ 0 75.6 &gt; 2 Revenue Revenue Invoice 2018-03-26 71065 Godwin~ Cand.~ Acco~ 0 75.6 &gt; 3 Revenue Revenue Invoice 2018-04-22 71064 Godwin~ Drop ~ Acco~ 0 75.6 &gt; 4 Revenue Revenue Invoice 2018-04-22 71064 Godwin~ Cand.~ Acco~ 0 75.6 &gt; 5 Revenue Revenue Invoice 2018-04-28 71066 Godwin~ Drop ~ Acco~ 0 75.6 &gt; 6 Revenue Revenue Invoice 2018-04-28 71066 Godwin~ Cand.~ Acco~ 0 75.6 &gt; 7 Revenue Revenue Invoice 2018-04-28 71067 Dan A.~ Fluor~ Acco~ 0 75 &gt; 8 Revenue Revenue Invoice 2018-05-10 71068 Godwin~ Drop ~ Acco~ 0 75.6 &gt; 9 Revenue Revenue Invoice 2018-05-10 71068 Godwin~ Cand.~ Acco~ 0 75.6 &gt; 10 Revenue Revenue Invoice 2018-05-16 71095 Miscel~ Penda~ Acco~ 0 75 &gt; # ... with 19 more rows, and 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, &gt; # month &lt;ord&gt;, quarter &lt;fct&gt; revenue %&gt;% dplyr::filter(credit &gt;= 10) %&gt;% group_by(credit) %&gt;% summarise(freq = n()) %&gt;% arrange(desc(freq)) %&gt;% mutate(first_two = sapply(credit, function(x) substring(x, first = c(1), last = c(2)))) %&gt;% count(first_two, sort = TRUE) &gt; # A tibble: 78 x 2 &gt; first_two n &gt; &lt;chr&gt; &lt;int&gt; &gt; 1 12 12 &gt; 2 13 9 &gt; 3 11 7 &gt; 4 18 7 &gt; 5 19 7 &gt; 6 10 6 &gt; 7 21 6 &gt; 8 22 6 &gt; 9 28 6 &gt; 10 14 5 &gt; # ... with 68 more rows 5.4.4 Outlier revenue[which(revenue$credit %in% c(boxplot.stats(revenue$credit)$out)), ] &gt; # A tibble: 105 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-14 71050 Godwi~ Pearl ~ Acco~ 0 2375 &gt; 2 Revenue Revenue Invoice 2018-01-14 71050 Godwi~ Roman ~ Acco~ 0 850 &gt; 3 Revenue Revenue Invoice 2018-01-14 71050 Godwi~ Tiffan~ Acco~ 0 1020 &gt; 4 Revenue Revenue Invoice 2018-01-14 71050 Godwi~ River ~ Acco~ 0 1800 &gt; 5 Revenue Revenue Invoice 2018-01-29 71124 Kern ~ Burnis~ Acco~ 0 8400 &gt; 6 Revenue Revenue Invoice 2018-02-01 71121 Kern ~ 18x8x1~ Acco~ 0 1320 &gt; 7 Revenue Revenue Invoice 2018-02-01 71121 Kern ~ 18x8x1~ Acco~ 0 1980 &gt; 8 Revenue Revenue Invoice 2018-02-01 71121 Kern ~ Solid ~ Acco~ 0 1260 &gt; 9 Revenue Revenue Invoice 2018-02-01 71121 Kern ~ White,~ Acco~ 0 960 &gt; 10 Revenue Revenue Invoice 2018-02-10 71051 Cole ~ Golden~ Acco~ 0 1890 &gt; # ... with 95 more rows, and 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, &gt; # month &lt;ord&gt;, quarter &lt;fct&gt; subset(revenue, revenue$credit %in% boxplot(revenue$credit ~ revenue$month)$out) &gt; # A tibble: 96 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-14 71050 Godwi~ Pearl ~ Acco~ 0 2375 &gt; 2 Revenue Revenue Invoice 2018-01-14 71050 Godwi~ Roman ~ Acco~ 0 850 &gt; 3 Revenue Revenue Invoice 2018-01-14 71050 Godwi~ Tiffan~ Acco~ 0 1020 &gt; 4 Revenue Revenue Invoice 2018-01-14 71050 Godwi~ River ~ Acco~ 0 1800 &gt; 5 Revenue Revenue Invoice 2018-01-29 71124 Kern ~ Burnis~ Acco~ 0 8400 &gt; 6 Revenue Revenue Invoice 2018-02-01 71121 Kern ~ 18x8x1~ Acco~ 0 1320 &gt; 7 Revenue Revenue Invoice 2018-02-01 71121 Kern ~ 18x8x1~ Acco~ 0 1980 &gt; 8 Revenue Revenue Invoice 2018-02-01 71121 Kern ~ Solid ~ Acco~ 0 1260 &gt; 9 Revenue Revenue Invoice 2018-02-01 71121 Kern ~ White,~ Acco~ 0 960 &gt; 10 Revenue Revenue Invoice 2018-02-10 71051 Cole ~ Golden~ Acco~ 0 1890 &gt; # ... with 86 more rows, and 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, &gt; # month &lt;ord&gt;, quarter &lt;fct&gt; revenue %&gt;% dplyr::filter(credit &gt; quantile(credit, prob = .95)) &gt; # A tibble: 41 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-14 71050 Godwi~ Pearl ~ Acco~ 0 2375 &gt; 2 Revenue Revenue Invoice 2018-01-29 71124 Kern ~ Burnis~ Acco~ 0 8400 &gt; 3 Revenue Revenue Invoice 2018-03-28 71071 Dan A~ Domes,~ Acco~ 0 4500 &gt; 4 Revenue Revenue Invoice 2018-03-28 71125 Kern ~ Vianne~ Acco~ 0 2900 &gt; 5 Revenue Revenue Invoice 2018-03-28 71125 Kern ~ Cand. ~ Acco~ 0 5600 &gt; 6 Revenue Revenue Invoice 2018-04-13 71126 Kern ~ Golden~ Acco~ 0 12600 &gt; 7 Revenue Revenue Invoice 2018-04-28 71067 Dan A~ Bevele~ Acco~ 0 2400 &gt; 8 Revenue Revenue Invoice 2018-04-28 71067 Dan A~ Flush ~ Acco~ 0 2975 &gt; 9 Revenue Revenue Invoice 2018-05-22 71127 Kern ~ Domes,~ Acco~ 0 6750 &gt; 10 Revenue Revenue Invoice 2018-06-10 71128 Kern ~ Fluore~ Acco~ 0 4500 &gt; # ... with 31 more rows, and 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, &gt; # month &lt;ord&gt;, quarter &lt;fct&gt; subset(revenue, revenue$credit &gt; (quantile(revenue$credit, .25) - 1.5*IQR(revenue$credit)) &amp; revenue$credit &lt; (quantile(revenue$credit, .75) + 1.5*IQR(revenue$credit))) &gt; # A tibble: 742 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-06 71047 Baker~ Pearl ~ Acco~ 0 570 &gt; 2 Revenue Revenue Invoice 2018-01-06 71047 Baker~ Black ~ Acco~ 0 84 &gt; 3 Revenue Revenue Invoice 2018-01-06 71047 Baker~ Bevele~ Acco~ 0 144 &gt; 4 Revenue Revenue Invoice 2018-01-06 71047 Baker~ Tiffan~ Acco~ 0 510 &gt; 5 Revenue Revenue Invoice 2018-01-06 71047 Baker~ Burnis~ Acco~ 0 600 &gt; 6 Revenue Revenue Invoice 2018-01-06 71047 Baker~ Specia~ Acco~ 0 55 &gt; 7 Revenue Revenue Invoice 2018-01-06 71047 Baker~ Pendan~ Acco~ 0 50 &gt; 8 Revenue Revenue Invoice 2018-01-06 71047 Baker~ Verona~ Acco~ 0 300 &gt; 9 Revenue Revenue Invoice 2018-01-06 71047 Baker~ Haloge~ Acco~ 0 12 &gt; 10 Revenue Revenue Invoice 2018-01-06 71047 Baker~ Cand. ~ Acco~ 0 56 &gt; # ... with 732 more rows, and 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, &gt; # month &lt;ord&gt;, quarter &lt;fct&gt; revenue[which(ecdf(revenue$credit)(revenue$credit) &gt; 0.95), ] &gt; # A tibble: 44 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-14 71050 Godwi~ Pearl ~ Acco~ 0 2375 &gt; 2 Revenue Revenue Invoice 2018-01-29 71124 Kern ~ Burnis~ Acco~ 0 8400 &gt; 3 Revenue Revenue Invoice 2018-03-28 71071 Dan A~ Domes,~ Acco~ 0 4500 &gt; 4 Revenue Revenue Invoice 2018-03-28 71125 Kern ~ Vianne~ Acco~ 0 2900 &gt; 5 Revenue Revenue Invoice 2018-03-28 71125 Kern ~ Cand. ~ Acco~ 0 5600 &gt; 6 Revenue Revenue Invoice 2018-04-13 71126 Kern ~ Golden~ Acco~ 0 12600 &gt; 7 Revenue Revenue Invoice 2018-04-28 71067 Dan A~ Coloni~ Acco~ 0 2100 &gt; 8 Revenue Revenue Invoice 2018-04-28 71067 Dan A~ Bevele~ Acco~ 0 2400 &gt; 9 Revenue Revenue Invoice 2018-04-28 71067 Dan A~ Flush ~ Acco~ 0 2975 &gt; 10 Revenue Revenue Invoice 2018-05-22 71127 Kern ~ Domes,~ Acco~ 0 6750 &gt; # ... with 34 more rows, and 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, &gt; # month &lt;ord&gt;, quarter &lt;fct&gt; revenue[which(abs(scale(revenue$credit)) &gt; 1.96), ] &gt; # A tibble: 33 x 14 &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-01-29 71124 Kern ~ Burnis~ Acco~ 0 8400 &gt; 2 Revenue Revenue Invoice 2018-03-28 71071 Dan A~ Domes,~ Acco~ 0 4500 &gt; 3 Revenue Revenue Invoice 2018-03-28 71125 Kern ~ Vianne~ Acco~ 0 2900 &gt; 4 Revenue Revenue Invoice 2018-03-28 71125 Kern ~ Cand. ~ Acco~ 0 5600 &gt; 5 Revenue Revenue Invoice 2018-04-13 71126 Kern ~ Golden~ Acco~ 0 12600 &gt; 6 Revenue Revenue Invoice 2018-04-28 71067 Dan A~ Flush ~ Acco~ 0 2975 &gt; 7 Revenue Revenue Invoice 2018-05-22 71127 Kern ~ Domes,~ Acco~ 0 6750 &gt; 8 Revenue Revenue Invoice 2018-06-10 71128 Kern ~ Fluore~ Acco~ 0 4500 &gt; 9 Revenue Revenue Invoice 2018-07-13 71119 Kern ~ Golden~ Acco~ 0 3150 &gt; 10 Revenue Revenue Invoice 2018-07-13 71119 Kern ~ Burnis~ Acco~ 0 3000 &gt; # ... with 23 more rows, and 4 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, &gt; # month &lt;ord&gt;, quarter &lt;fct&gt; revenue %&gt;% mutate(z_score = scale(credit), z_label = ifelse(abs(z_score - mean(z_score)) &gt; 2*sd(z_score), &quot;z&quot;, &quot;ok&quot;)) %&gt;% dplyr::filter(z_label == &quot;z&quot;) %&gt;% ggplot() + geom_point(aes(credit, month, size = credit &gt; 6000), alpha = .5) + geom_point(aes(credit, month, color = &quot;red&quot;)) + geom_vline(xintercept = 6000, lty = 2, col = &quot;red&quot;, size = 1) + ggrepel::geom_text_repel(data = subset(revenue, credit &gt; 6000), aes(credit, month, label = name), col = &quot;steelblue&quot;, size = 3) + scale_x_continuous(labels = scales::comma_format()) + scale_colour_manual(values = c(&quot;red&quot;), guide = FALSE) + scale_size_manual(values = c(1, 3), guide = FALSE) + annotate(&quot;text&quot;, x = 6200, y = 6, label = &quot;6,000&quot;, size = 3) + theme(legend.position = &quot;none&quot;) + theme_minimal() + labs(title = &quot;Identification of sales outlier based on Z-score&quot;, x = NULL, y = NULL) 5.4.5 Ratios Remove any rows containing 0 in monthly financial statements, and then perform horizontal and vertical ratio analysis. The final result is present in a formatted table. mth_fs[apply(mth_fs[-c(1:2)], 1, function(x) all(x != 0)), ] &gt; # A tibble: 30 x 14 &gt; account subaccount Jan Feb Mar Apr May Jun Jul &gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Accounts ~ Accounts Pay~ -3.59e4 -45421 -21732. -23299 -3916. -6852. -4067. &gt; 2 Accounts ~ Accounts Rec~ 2.24e4 10455. 16399. 16583. 21162. 26078. 38024. &gt; 3 Accumulat~ Accumulated ~ -7.69e1 -154. -231. -308. -385. -462. -538. &gt; 4 Car/Truck~ Car Lease 5.63e2 1126 1689 2252 2815 3378 3941 &gt; 5 Car/Truck~ Insurance-Au~ 1.2 e2 240 360 480 600 720 840 &gt; 6 Company C~ Company Chec~ 2.14e4 25957. 44125. 7784. 35514. 76992. 42187. &gt; 7 Deborah W~ Deborah Wood~ 1.05e4 22750 32750 44500 56500 67750 77750 &gt; 8 Depreciat~ Depreciation~ 7.69e1 154. 231. 308. 385. 462. 538. &gt; 9 Direct La~ Wages - Ware~ 8.1 e2 2430 4050 5670 7290 8910 10530 &gt; 10 Insurance General Liab~ 2.3 e2 460 690 920 1150 1380 1610 &gt; # ... with 20 more rows, and 5 more variables: Aug &lt;dbl&gt;, Sep &lt;dbl&gt;, Oct &lt;dbl&gt;, &gt; # Nov &lt;dbl&gt;, Dec &lt;dbl&gt; mth_fs %&gt;% rowwise() %&gt;% dplyr::filter(all(c_across(-c(account, subaccount)) != 0)) &gt; # A tibble: 30 x 14 &gt; # Rowwise: &gt; account subaccount Jan Feb Mar Apr May Jun Jul &gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Accounts ~ Accounts Pay~ -3.59e4 -45421 -21732. -23299 -3916. -6852. -4067. &gt; 2 Accounts ~ Accounts Rec~ 2.24e4 10455. 16399. 16583. 21162. 26078. 38024. &gt; 3 Accumulat~ Accumulated ~ -7.69e1 -154. -231. -308. -385. -462. -538. &gt; 4 Car/Truck~ Car Lease 5.63e2 1126 1689 2252 2815 3378 3941 &gt; 5 Car/Truck~ Insurance-Au~ 1.2 e2 240 360 480 600 720 840 &gt; 6 Company C~ Company Chec~ 2.14e4 25957. 44125. 7784. 35514. 76992. 42187. &gt; 7 Deborah W~ Deborah Wood~ 1.05e4 22750 32750 44500 56500 67750 77750 &gt; 8 Depreciat~ Depreciation~ 7.69e1 154. 231. 308. 385. 462. 538. &gt; 9 Direct La~ Wages - Ware~ 8.1 e2 2430 4050 5670 7290 8910 10530 &gt; 10 Insurance General Liab~ 2.3 e2 460 690 920 1150 1380 1610 &gt; # ... with 20 more rows, and 5 more variables: Aug &lt;dbl&gt;, Sep &lt;dbl&gt;, Oct &lt;dbl&gt;, &gt; # Nov &lt;dbl&gt;, Dec &lt;dbl&gt; mth_fs_0 &lt;- mth_fs %&gt;% select(-account) %&gt;% rowwise() %&gt;% dplyr::filter(all(c_across(-c(subaccount)) != 0)) %&gt;% column_to_rownames(&#39;subaccount&#39;) cogs_sales &lt;- mth_fs_0[&quot;Purchases (Cost of Goods)&quot;, ] / abs(mth_fs_0[&#39;Revenue&#39;, ]) inventory_cogs &lt;- mth_fs_0[&quot;Purchases (Cost of Goods)&quot;, ] / mth_fs_0[&#39;Inventory Asset&#39;, ] mth_fs_0_ratio &lt;- mth_fs_0 %&gt;% add_row(cogs_sales) %&gt;% add_row(inventory_cogs) %&gt;% rownames_to_column(&quot;Subaccount&quot;) mth_fs_0_ratio[31, &quot;Subaccount&quot;] &lt;- &quot;COGS/Sales&quot; mth_fs_0_ratio[32, &quot;Subaccount&quot;] &lt;- &quot;COGS/Inventory&quot; report_tbl &lt;- mth_fs_0_ratio %&gt;% dplyr::filter( Subaccount %in% c(&quot;Revenue&quot;, &quot;Purchases (Cost of Goods)&quot;, &quot;Inventory Asset&quot;, &quot;COGS/Sales&quot;, &quot;COGS/Inventory&quot;) ) %&gt;% mutate( Jan_Feb = (Feb - Jan)/Jan, Feb_Mar = (Mar - Feb)/Feb, Mar_Apr = (Apr - Mar)/Mar, Apr_May = (May - Apr)/Apr, May_Jun = (Jun - May)/May, Jun_Jul = (Jul - Jun)/Jun, Jul_Aug = (Aug - Jul)/Jul, Aug_Sep = (Sep - Aug)/Aug, Sep_Oct = (Oct - Sep)/Sep, Oct_Nov = (Nov - Oct)/Oct, Nov_Dec = (Dec - Nov)/Nov ) %&gt;% select(-c(Jan:Dec)) %&gt;% mutate(across(-c(Subaccount), ~formattable::comma(round(abs(.x), 2)))) report_tbl %&gt;% kableExtra::kbl(caption = &quot;Horizontal and Vertical Analysis&quot;) %&gt;% kableExtra::kable_paper(&quot;hover&quot;, full_width = FALSE) %&gt;% kableExtra::add_header_above(c(&quot;Financial Year ended as at 31/12/2018&quot; = 12), background = &quot;teal&quot;, color = &quot;white&quot;, bold = TRUE, align = &quot;left&quot;) %&gt;% kableExtra::row_spec(4:5, color = &quot;white&quot;, background = &quot;pink&quot;) %&gt;% kableExtra::column_spec(2, color = &quot;white&quot;, background = &quot;pink&quot;) %&gt;% kableExtra::footnote(symbol = c(&quot;COGS and Revenue decrease over the period; &quot;, &quot;COGS/Inventory decrease over the period; &quot;), footnote_as_chunk = FALSE) knitr::include_graphics(&quot;img/ratio_tbl.png&quot;) 5.4.6 Cutomers Identify Top 10 customers based on total sales amount. revenue %&gt;% count(name, wt = credit, sort = TRUE) &gt; # A tibble: 54 x 2 &gt; name n &gt; &lt;chr&gt; &lt;dbl&gt; &gt; 1 Kern Lighting Warehouse:Store #13 37725 &gt; 2 Kern Lighting Warehouse:Store #01 34929 &gt; 3 Kern Lighting Warehouse:Store #34 34625. &gt; 4 Kern Lighting Warehouse:Store #45 30675 &gt; 5 Cole Home Builders:Phase 1 - Lot 5 25877. &gt; 6 Stern Commercial Contractor&#39;s:Walker Properties 21330 &gt; 7 Stern Commercial Contractor&#39;s:Tittle Properties 17433 &gt; 8 Thompson Lighting Stores:Store #15 14825 &gt; 9 Stern Commercial Contractor&#39;s:Wilson Suites 14355 &gt; 10 Cole Home Builders:Phase 2 - Lot 5 13973. &gt; # ... with 44 more rows revenue %&gt;% mutate(name = fct_lump(name, 10, w = credit), name = fct_reorder(name, credit, sum)) %&gt;% ggplot(aes(credit, name)) + geom_col() + scale_x_continuous(label = scales::comma) + labs(x = &quot;&quot;, y = &quot;&quot;) + theme_light() summarize a table for customers, which includes how much they purchased on weekends. revenue %&gt;% group_by(name) %&gt;% arrange(date) %&gt;% summarise(n = n(), across(credit, tibble::lst(sum, sd, mean, median, min, max, first, last)), weekend_n = length(credit[weekday %in% c(&quot;Sat&quot;, &quot;Sun&quot;)]), weekend_sum = sum(credit[weekday %in% c(&quot;Sat&quot;, &quot;Sun&quot;)]), .groups = &quot;drop&quot;) &gt; # A tibble: 54 x 12 &gt; name n credit_sum credit_sd credit_mean credit_median credit_min &gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Baker&#39;s Prof~ 7 2391 284. 342. 232 50 &gt; 2 Baker&#39;s Prof~ 13 12718. 1175. 978. 582 22 &gt; 3 Baker&#39;s Prof~ 17 3307 155. 195. 210 9 &gt; 4 Baker&#39;s Prof~ 8 1872 249. 234 129 11 &gt; 5 Baker&#39;s Prof~ 10 2381 237. 238. 114 12 &gt; 6 Cole Home Bu~ 17 2187. 124. 129. 86.4 4.95 &gt; 7 Cole Home Bu~ 17 2187. 124. 129. 86.4 4.95 &gt; 8 Cole Home Bu~ 196 25877. 96.0 132. 104. 4.95 &gt; 9 Cole Home Bu~ 81 13973. 250. 173. 112 4.95 &gt; 10 Dan A. North~ 1 7000 NA 7000 7000 7000 &gt; # ... with 44 more rows, and 5 more variables: credit_max &lt;dbl&gt;, &gt; # credit_first &lt;dbl&gt;, credit_last &lt;dbl&gt;, weekend_n &lt;int&gt;, weekend_sum &lt;dbl&gt; Relative size factor (RSF) compares the biggest sales to the second biggest sales. revenue %&gt;% group_by(name) %&gt;% arrange(desc(credit)) %&gt;% slice(1:2) %&gt;% mutate(rsf = round(credit / dplyr::lag(credit), digits = 3)) %&gt;% dplyr::filter(rsf &lt; 0.5) &gt; # A tibble: 6 x 15 &gt; # Groups: name [6] &gt; account subaccount type date num name memo split debit credit &gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 Revenue Revenue Invoice 2018-03-28 71071 Dan A.~ Flat G~ Acco~ 0 1875 &gt; 2 Revenue Revenue Invoice 2018-11-01 71120 Kern L~ 18x8x1~ Acco~ 0 3300 &gt; 3 Revenue Revenue Invoice 2018-02-28 71122 Lavery~ Custom~ Acco~ 0 600 &gt; 4 Revenue Revenue Invoice 2018-09-25 71100 Miscel~ Verona~ Acco~ 0 600 &gt; 5 Revenue Revenue Invoice 2018-12-10 71105 Miscel~ Chestn~ Acco~ 0 325 &gt; 6 Revenue Revenue Invoice 2018-04-10 71057 Miscel~ Domes,~ Acco~ 0 180 &gt; # ... with 5 more variables: balance &lt;dbl&gt;, weekday &lt;ord&gt;, month &lt;ord&gt;, &gt; # quarter &lt;fct&gt;, rsf &lt;dbl&gt; revenue %&gt;% nest(data = -c(name)) %&gt;% mutate(max_sales = map(data, ~max(.x[&#39;credit&#39;]))) %&gt;% unnest(max_sales) &gt; # A tibble: 54 x 3 &gt; name data max_sales &gt; &lt;chr&gt; &lt;list&gt; &lt;dbl&gt; &gt; 1 Baker&#39;s Professional Lighting:Store #25 &lt;tbl_df [10 x 13]&gt; 600 &gt; 2 Godwin Lighting Depot:Store #202 &lt;tbl_df [19 x 13]&gt; 2375 &gt; 3 Miscellaneous - Retail:Ms. Jann Minor &lt;tbl_df [6 x 13]&gt; 350 &gt; 4 Miscellaneous - Retail:Brian Stern &lt;tbl_df [6 x 13]&gt; 300 &gt; 5 Miscellaneous - Retail:Alison Johnson &lt;tbl_df [4 x 13]&gt; 400 &gt; 6 Cole Home Builders:Phase 2 - Lot 5 &lt;tbl_df [81 x 13]&gt; 1890 &gt; 7 Kern Lighting Warehouse:Store #34 &lt;tbl_df [21 x 13]&gt; 8400 &gt; 8 Godwin Lighting Depot:Store #303 &lt;tbl_df [38 x 13]&gt; 585 &gt; 9 Thompson Lighting Stores:Store #15 &lt;tbl_df [27 x 13]&gt; 2170 &gt; 10 Cole Home Builders:Phase 1 - Lot 2 &lt;tbl_df [17 x 13]&gt; 367. &gt; # ... with 44 more rows revenue %&gt;% split(.$name) %&gt;% sapply(function(x) max(x$credit)) %&gt;% as.data.frame() &gt; . &gt; Baker&#39;s Professional Lighting:Store #05 850.0 &gt; Baker&#39;s Professional Lighting:Store #10 3432.0 &gt; Baker&#39;s Professional Lighting:Store #15 600.0 &gt; Baker&#39;s Professional Lighting:Store #20 630.0 &gt; Baker&#39;s Professional Lighting:Store #25 600.0 &gt; Cole Home Builders:Phase 1 - Lot 2 367.2 &gt; Cole Home Builders:Phase 1 - Lot 4 367.2 &gt; Cole Home Builders:Phase 1 - Lot 5 367.2 &gt; Cole Home Builders:Phase 2 - Lot 5 1890.0 &gt; Dan A. North Builders:Custom Order - Suite 100A 7000.0 &gt; Dan A. North Builders:McCarthy Properties 4500.0 &gt; Dan A. North Builders:Turner Suites 5000.0 &gt; Dan A. North Builders:Wagner Suites 2975.0 &gt; Godwin Lighting Depot:Store #1020 585.0 &gt; Godwin Lighting Depot:Store #202 2375.0 &gt; Godwin Lighting Depot:Store #303 585.0 &gt; Godwin Lighting Depot:Store #404 585.0 &gt; Godwin Lighting Depot:Store #909 585.0 &gt; Kern Lighting Warehouse:Store #01 7875.0 &gt; Kern Lighting Warehouse:Store #13 12600.0 &gt; Kern Lighting Warehouse:Store #34 8400.0 &gt; Kern Lighting Warehouse:Store #45 5600.0 &gt; Lavery Lighting &amp; Design:Store #JL-01 1020.0 &gt; Lavery Lighting &amp; Design:Store #JL-04 2500.0 &gt; Lavery Lighting &amp; Design:Store #JL-06 1860.0 &gt; Lavery Lighting &amp; Design:Store #JL-08 1275.0 &gt; Miscellaneous - Retail:Alison Johnson 400.0 &gt; Miscellaneous - Retail:Anne Loomis 680.0 &gt; Miscellaneous - Retail:Brian Stern 300.0 &gt; Miscellaneous - Retail:Carlos Nazar 620.0 &gt; Miscellaneous - Retail:David Lo 650.0 &gt; Miscellaneous - Retail:Doug Jacobsen 900.0 &gt; Miscellaneous - Retail:Jann Minor 975.0 &gt; Miscellaneous - Retail:Jason Helper 700.0 &gt; Miscellaneous - Retail:John Huhn 1275.0 &gt; Miscellaneous - Retail:Lara Gussman 748.0 &gt; Miscellaneous - Retail:Melanie Hall 500.0 &gt; Miscellaneous - Retail:Mr. Fred Kaseman 620.0 &gt; Miscellaneous - Retail:Mr. Jay Jessen 975.0 &gt; Miscellaneous - Retail:Mrs. Anne Hemp 600.0 &gt; Miscellaneous - Retail:Mrs. Chris Holly 500.0 &gt; Miscellaneous - Retail:Ms. Jann Minor 350.0 &gt; Miscellaneous - Retail:Peter Karpas 680.0 &gt; Miscellaneous - Retail:Ruth Kuver 650.0 &gt; Miscellaneous - Retail:Sean Martin 750.0 &gt; Miscellaneous - Retail:Valesha Jones 945.0 &gt; Stern Commercial Contractor&#39;s:Tittle Properties 6300.0 &gt; Stern Commercial Contractor&#39;s:Walker Properties 8100.0 &gt; Stern Commercial Contractor&#39;s:Wilson Suites 6300.0 &gt; Thompson Lighting Stores:Store #15 2170.0 &gt; Thompson Lighting Stores:Store #20 475.0 &gt; Thompson Lighting Stores:Store #30 475.0 &gt; Thompson Lighting Stores:Store #40 475.0 &gt; Thompson Lighting Stores:Store #50 475.0 revenue %&gt;% group_by(name) %&gt;% dplyr::filter(cumany(credit &gt; 5000)) %&gt;% summarise(range_credit = range(credit)) &gt; # A tibble: 16 x 2 &gt; # Groups: name [8] &gt; name range_credit &gt; &lt;chr&gt; &lt;dbl&gt; &gt; 1 Dan A. North Builders:Custom Order - Suite 100A 7000 &gt; 2 Dan A. North Builders:Custom Order - Suite 100A 7000 &gt; 3 Kern Lighting Warehouse:Store #01 75 &gt; 4 Kern Lighting Warehouse:Store #01 7875 &gt; 5 Kern Lighting Warehouse:Store #13 0 &gt; 6 Kern Lighting Warehouse:Store #13 12600 &gt; 7 Kern Lighting Warehouse:Store #34 58 &gt; 8 Kern Lighting Warehouse:Store #34 8400 &gt; 9 Kern Lighting Warehouse:Store #45 55 &gt; 10 Kern Lighting Warehouse:Store #45 5600 &gt; 11 Stern Commercial Contractor&#39;s:Tittle Properties 198 &gt; 12 Stern Commercial Contractor&#39;s:Tittle Properties 6300 &gt; 13 Stern Commercial Contractor&#39;s:Walker Properties 1350 &gt; 14 Stern Commercial Contractor&#39;s:Walker Properties 8100 &gt; 15 Stern Commercial Contractor&#39;s:Wilson Suites 5760 &gt; 16 Stern Commercial Contractor&#39;s:Wilson Suites 6300 Perform the customer churn analysis and identify one time customers based on specific characteristics. revenue %&gt;% select(date, name, credit) %&gt;% mutate(date = lubridate::ceiling_date(date, &quot;day&quot;)) %&gt;% group_by(name) %&gt;% mutate(revenue = sum(credit), last_visit = last(date), last_days = as.double(as.Date(&quot;2018-12-31&quot;) - last_visit), orders = n()) %&gt;% select(-c(date, credit)) %&gt;% distinct(last_visit, .keep_all = TRUE) %&gt;% ggplot(aes(last_days, orders, size = revenue)) + geom_point() + geom_text(aes(label = paste0 (name, &quot; | &quot;, last_visit)), hjust = 0, vjust = 1, check_overlap = TRUE, size = 3, col = &quot;steelblue&quot;) + scale_x_continuous(labels = function(x) paste0(x, &quot;/days&quot;)) + scale_y_continuous(labels = function(x) paste0(x, &quot;/orders&quot;)) + scale_size_continuous(name = &quot;Revenue&quot;, labels = scales::comma_format()) + theme_minimal() + theme(legend.justification = c(1, 1), legend.position = c(0.95, 0.95), legend.background = element_blank()) + labs(x = &quot;&quot;, y = &quot;&quot;) # prcomp() 5.5 Substantive test gl_df %&gt;% dplyr::filter(subaccount %in% c(&quot;Revenue&quot;, &quot;Accounts Receivable&quot;)) %&gt;% group_by(subaccount, month) %&gt;% summarise_at(vars(debit, credit), sum) %&gt;% mutate(amt = case_when(subaccount == &quot;Accounts Receivable&quot; ~ debit - credit, subaccount == &quot;Revenue&quot; ~ credit - debit)) %&gt;% ggplot(aes(month, amt, color = subaccount)) + geom_point(show.legend = FALSE) + geom_path(aes(group = subaccount), show.legend = FALSE) + geom_hline(yintercept = 0, lty = 2, col = &quot;black&quot;, size = 1) + scale_y_continuous(breaks = seq(-30000, 80000, 10000), labels = scales::comma_format()) + theme_light() + labs(title = &quot;Monthly movement for FY2018&quot;, x = NULL, y = NULL, color = &quot;&quot;) 5.5.1 Reconcilation Reconcile revenue to account receivables as of year end. Ensure that sub ledger agrees to GL by check total and cross check. gl_df %&gt;% dplyr::filter(subaccount == &quot;Accounts Receivable&quot;) %&gt;% summarise(across(c(debit, credit), sum), .groups = &quot;drop&quot;) &gt; # A tibble: 1 x 2 &gt; debit credit &gt; &lt;dbl&gt; &lt;dbl&gt; &gt; 1 408310. 375976. reconcilation &lt;- gl_df %&gt;% dplyr::filter(subaccount %in% c(&quot;Revenue&quot;, &quot;Accounts Receivable&quot;)) %&gt;% group_by(name, subaccount) %&gt;% summarise(across(c(debit, credit), sum), .groups = &quot;drop&quot;) %&gt;% mutate(confirmation = ifelse(subaccount == &quot;Revenue&quot;, credit - debit, debit - credit)) %&gt;% spread(subaccount, confirmation, fill = 0) %&gt;% mutate(client = word(name)) reconcilation %&gt;% group_by(&quot;Client&quot; = client) %&gt;% summarise(across(c(Revenue, `Accounts Receivable`), sum), .groups = &quot;drop&quot;) %&gt;% janitor::adorn_totals() &gt; Client Revenue Accounts Receivable &gt; Baker&#39;s 22669.48 12102.48 &gt; Cole 44225.00 0.00 &gt; Dan 37119.00 3500.00 &gt; Godwin 31699.85 0.00 &gt; Kern 137953.60 2222.50 &gt; Lavery 24996.60 2708.10 &gt; Miscellaneous 33103.00 0.00 &gt; Stern 53118.00 0.00 &gt; Thompson 26925.00 11800.00 &gt; Total 411809.53 32333.08 5.5.2 Aging report age_customer &lt;- reconcilation %&gt;% dplyr::filter(`Accounts Receivable` != 0) %&gt;% pull(name) age_inv &lt;- gl_df %&gt;% dplyr::filter(subaccount == &quot;Accounts Receivable&quot;, name %in% age_customer) %&gt;% group_by(name) %&gt;% mutate(index = map(debit, ~case_when(.x == 0 ~ 2, .x == credit ~ 1)), unpaid = map_dbl(index, sum, na.rm = TRUE)) %&gt;% dplyr::filter(unpaid == 0) %&gt;% mutate(age = ifelse((date + lubridate::days(30)) &lt; as.Date(&quot;2019-1-31&quot;), &quot;Ok&quot;, &quot;Overdue&quot;)) library(kableExtra) age_inv %&gt;% select(account, type, date, num, name, debit, credit) %&gt;% mutate(across(c(debit, credit), ~ scales::comma(round(.x)))) %&gt;% rename_with(toupper) %&gt;% kable(caption = &quot;RAudit Solution LLP&quot;) %&gt;% kable_styling(full_width = FALSE, font_size = 12) %&gt;% add_header_above(c(&quot;Financial Year ended as at 31/12/2018&quot; = 7), background = &quot;teal&quot;, color = &quot;white&quot;, bold = TRUE, align = &quot;left&quot;) %&gt;% column_spec(1, bold = TRUE) %&gt;% collapse_rows(columns = c(1), valign = &quot;middle&quot;) %&gt;% footnote(title_format = c(&quot;italic&quot;, &quot;underline&quot;), general = &quot;Please return the confirmation letter to us as soon as possible.&quot;) knitr::include_graphics(&quot;img/age_report.png&quot;) 5.5.3 Confirmation letter Produce confirmation letters for all customers with due account receivable amount in one go. tibble(customer = unique(age_inv$name), filename = here::here(paste0(&quot;confirmation/&quot;, &quot;confirmation_&quot;, seq(length(unique(age_inv$name))), &quot;.html&quot;)), params = map(customer, ~ list(customer = .))) %&gt;% select(output_file = filename, params) %&gt;% pwalk(rmarkdown::render, input = here::here(&quot;confirmation/confirmation.Rmd&quot;), &quot;html_document&quot;, envir = new.env()) paste0(&quot;confirmation/&quot;, list.files(here::here(&quot;confirmation&quot;), &quot;*.html&quot;)) %&gt;% map(file.remove) knitr::include_graphics(&quot;img/confirm_letter.png&quot;) 5.6 Reporting Audit report needs to be filled up with numbers after finalized draft financial statements. fload &lt;- function(df, cell){ pos &lt;- strsplit(cell, split = &#39;_&#39;) %&gt;% unlist() df %&gt;% dplyr::filter(table == pos[1], row_number() == pos[2]) %&gt;% select(pos[3]) %&gt;% pull() } df &lt;- head(mtcars) %&gt;% rownames_to_column(&#39;car&#39;) %&gt;% mutate(table = &#39;table1&#39;) knitr::include_graphics(&quot;img/audit_report.png&quot;) "],["utilities.html", "Chapter 6 Utilities 6.1 Command line tool 6.2 PDF data 6.3 Learnr", " Chapter 6 Utilities 6.1 Command line tool Write and run a R script on a terminal. st_cml &lt;- function(df){ cat(paste0(&quot;Your dataset has&quot;, &#39;\\x1b[6;30;42m&#39;, &quot;[&quot;, dim(df)[1], &quot; &quot;, dim(df)[2], &quot;]&quot;, &#39;\\x1b[0m&#39;, &quot;rows and columns&quot;, &quot;.\\n&quot;)) } main &lt;- function() { args &lt;- commandArgs(trailingOnly = TRUE) f &lt;- args[1] stopifnot(&quot;Please specificy a csv file&quot; = length(f) == 1) stopifnot(&quot;Please specificy a csv file&quot; = tools::file_ext(&quot;data/gl.csv&quot;) == &quot;csv&quot;) st_cml(read.csv(file = f)) } main() knitr::include_graphics(&quot;img/cml1.png&quot;) knitr::include_graphics(&quot;img/cml2.png&quot;) 6.2 PDF data Data inside of PDF documents can be extracted via pdftools. Data inside of a website can be pulled out via rvest. Web scrapping is not covered here. For a detailed example, refer to Listed companies in Singapore. txt &lt;- pdftools::pdf_text(here::here(&quot;suppliments/subset_2017.pdf&quot;)) txt1 &lt;- txt[1] %&gt;% str_split(&quot;\\n&quot;) %&gt;% unlist() txt1_start &lt;- stringr::str_which(txt1, &quot;Property, plant and equipment&quot;) txt1_end &lt;- stringr::str_which(txt1, &quot;Net assets&quot;) txt1_raw &lt;- txt1[txt1_start:txt1_end] %&gt;% str_trim() %&gt;% str_replace_all(&quot;\\\\s{2,}&quot;, &quot;|&quot;) %&gt;% str_remove_all(&quot;,&quot;) %&gt;% enframe() %&gt;% separate(value, into = c(&quot;account&quot;, &quot;note&quot;, &quot;group2017&quot;, &quot;group2016&quot;, &quot;company2017&quot;, &quot;company2016&quot;), sep = &quot;\\\\|&quot;, extra = &quot;merge&quot;, fill = &quot;right&quot;) %&gt;% dplyr::filter(!str_detect(account, &quot;[0-9]&quot;)) %&gt;% dplyr::filter(!account %in% c(&quot;Intangible assets arising from service&quot;, &quot;Trade and other receivables including&quot;, &quot;Liabilities&quot;, &quot;Trade and other payables including&quot;)) %&gt;% mutate(account = case_when( account == &quot;concession arrangements&quot; ~ &quot;Intangible assets arising from service concession arrangements&quot;, account == &#39;derivatives&#39; &amp; group2017 == 3000 ~ &quot;Trade and other receivables including derivatives&quot;, account == &#39;derivatives&#39; &amp; group2017 == 248791 ~ &quot;Trade and other receivables including derivatives&quot;, account == &#39;derivatives&#39; &amp; group2017 == 491526 ~ &quot;Trade and other payables including derivatives&quot;, account == &#39;derivatives&#39; &amp; group2017 == 35895 ~ &quot;Trade and other payables including derivatives&quot;, TRUE ~ account)) txt1_raw[txt1_raw$account == &quot;Non-current assets&quot;, ][3:ncol(txt1_raw)] &lt;- txt1_raw[txt1_raw$account == &quot;Non-current assets&quot;, ][2:(ncol(txt1_raw)-1)] txt1_raw[txt1_raw$account == &quot;Current assets&quot;, ][3:ncol(txt1_raw)] &lt;- txt1_raw[txt1_raw$account == &quot;Current assets&quot;, ][2:(ncol(txt1_raw)-1)] txt1_raw[txt1_raw$account == &quot;Total assets&quot;, ][3:ncol(txt1_raw)] &lt;- txt1_raw[txt1_raw$account == &quot;Total assets&quot;, ][2:(ncol(txt1_raw)-1)] txt1_raw[txt1_raw$account == &quot;Current liabilities&quot;, ][3:ncol(txt1_raw)] &lt;- txt1_raw[txt1_raw$account == &quot;Current liabilities&quot;, ][2:(ncol(txt1_raw)-1)] txt1_raw[txt1_raw$account == &quot;Net current assets&quot;, ][3:ncol(txt1_raw)] &lt;- txt1_raw[txt1_raw$account == &quot;Net current assets&quot;, ][2:(ncol(txt1_raw)-1)] txt1_raw[txt1_raw$account == &quot;Non-current liabilities&quot;, ][3:ncol(txt1_raw)] &lt;- txt1_raw[txt1_raw$account == &quot;Non-current liabilities&quot;, ][2:(ncol(txt1_raw)-1)] txt1_raw[txt1_raw$account == &quot;Net assets&quot;, ][3:ncol(txt1_raw)] &lt;- txt1_raw[txt1_raw$account == &quot;Net assets&quot;, ][2:(ncol(txt1_raw)-1)] txt1_raw[txt1_raw$account == &quot;Tax payable&quot;, ][3:ncol(txt1_raw)] &lt;- txt1_raw[txt1_raw$account == &quot;Tax payable&quot;, ][2:(ncol(txt1_raw)-1)] txt1_clean &lt;- txt1_raw %&gt;% select(-name) %&gt;% mutate(across(-c(account), readr::parse_number)) write.csv(txt1_clean, here::here(&quot;suppliments/txt1.csv&quot;)) knitr::include_graphics(&quot;img/pdf.png&quot;) 6.3 Learnr You can easily make a interactive training materials to facilitate new staffs to get off the ground as quickly as possible. knitr::include_graphics(&quot;img/learnr1.png&quot;) knitr::include_graphics(&quot;img/learnr2.png&quot;) knitr::include_graphics(&quot;img/learnr3.png&quot;) "],["references.html", "References", " References "]]
